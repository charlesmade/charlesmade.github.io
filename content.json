{"meta":{"title":"Zeco's blog","subtitle":null,"description":null,"author":"Zeco","url":"http://zeco.oschina.io"},"pages":[{"title":"About","date":"un11fin11","updated":"un11fin11","comments":true,"path":"about/index.html","permalink":"http://zeco.oschina.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"un11fin11","updated":"un11fin11","comments":true,"path":"categories/index.html","permalink":"http://zeco.oschina.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"un11fin11","updated":"un11fin11","comments":true,"path":"tags/index.html","permalink":"http://zeco.oschina.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mysql 优化(II) 引擎","slug":"mysql_uh2","date":"un44fin44","updated":"un33fin33","comments":true,"path":"2016/04/21/mysql_uh2/","link":"","permalink":"http://zeco.oschina.io/2016/04/21/mysql_uh2/","excerpt":"这里，只简单的讨论两种常见的引擎：MyISAM和InnoDB的区别。","text":"这里，只简单的讨论两种常见的引擎：MyISAM和InnoDB的区别。 MyISAM&nbsp;&nbsp;&nbsp;&nbsp;在MySQL版本小于等于5.5时，MyISAM是MySQL的默认引擎。他是ISAM的扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MYISAM还使用一种表格锁定的机制，来优化多个并发的读写操作。MYISAM还有一些有用的扩展，例如MYISAMPACK压缩工具，用于极少修改和新增数据的表格，提升其读取速度。 ISAM:Indexed Sequential Access Method(索引顺序存取方法)。属于文件系统其特点是所有表的数据文件都是单独存放的, 表中的索引和数据也是单独存放的, 只需扫描单个表即可得到结果，大大提高了查询的效率和速度 &nbsp;&nbsp;&nbsp;&nbsp;MYISAM的快速读取特性，符合了WEB开发过程中对大量进行的数据读取操作的需要，使其受到了许多WEB开发者的青睐。 InnoDB&nbsp;&nbsp;&nbsp;&nbsp;在MySQL版本大于5.5时，InnoDB是MySQL的默认引擎。InnoDB的最大特点是其对ACID事务的支持，外键约束，以及行级锁定（row-level locking）的特点，这是的InnoDB在处理巨大数据量（高并发）条件下较MyISAM有着更大的优势。 MyISAM 与 InnoDB的异同 诚然，这里只是简单的对两种常见的Mysql数据库引擎特点进行区分，数据表locking-level不可能只是如此简单的由引擎来决定，还有更加底层的B-TREE以及B+TREE结构，都不是本人现在水平可以涉及的深度，望勤望勉。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://zeco.oschina.io/categories/mysql/"}],"tags":[{"name":"mysql引擎","slug":"mysql引擎","permalink":"http://zeco.oschina.io/tagcloud/mysql引擎/"}]},{"title":"Mysql 优化(I) 数据表设计规范","slug":"mysql_uh1","date":"un00fin00","updated":"un33fin33","comments":true,"path":"2016/04/03/mysql_uh1/","link":"","permalink":"http://zeco.oschina.io/2016/04/03/mysql_uh1/","excerpt":"三范式&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。三范式的具体要求如下： 原子性（不可再分的字段） 非主键字段必须依赖主键 消除非主键之间的传递依赖","text":"三范式&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。三范式的具体要求如下： 原子性（不可再分的字段） 非主键字段必须依赖主键 消除非主键之间的传递依赖 &nbsp;&nbsp;&nbsp;&nbsp;当然，三范式在网上存在许多不同的版本，但不论是哪个版本的三范式，其中心思想都是一样的，那就是设计出比较合理的数据表，尽可能的减少代码的冗余。 但需要注意的是，代码的冗余只能减少，而不是消灭 具体设计思路如下： id name order order_name address weather price (非设计规范表) (拆分address字段保证设计表的原子性) -&gt; id name order order_name country province city weather price (将非主键依赖的weather的字段拆分出去) -&gt; id name order order_name country province city price (消除order和order_name之间的传递依赖，将非主键之间的传递依赖消除) -&gt; id name order country province city price 逆范式&nbsp;&nbsp;&nbsp;&nbsp;实际项目中，并不是完全按三范式的规范来设计表的结构，具体的项目中，逆范式的设计有时候可以简化sql的语句，提高sql语句的执行效率，此时逆范式的设计明显更有利于我们的项目，这个情况下使用逆范式的设计将更为科学。 例如，我们现在有两张表，一张分类表（category），一张商品表（goods），这里我们项目需要查询分类id、分类名称、商品数量三个字段，具体的sql语句如下： select c.*,count(g.goods_id) goods_num from category as c left join goods as g on c.cat_id = g.cat_id group by c.cat_id; 可以看到，这个使用jion连表查询的sql语句相对于简单的表结构并不简单，而如果我们给分类表加上一个对应的商品数量字段，这样的sql语句将大大简化，这个时候我们大可不必严守三范式的设计思路，不妨使用逆范式的方式来设计这张表。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://zeco.oschina.io/categories/mysql/"}],"tags":[{"name":"mysql表设计","slug":"mysql表设计","permalink":"http://zeco.oschina.io/tagcloud/mysql表设计/"}]}]}