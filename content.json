{"meta":{"title":"Zeco's blog","subtitle":null,"description":null,"author":"Zeco","url":"http://zeco.oschina.io"},"pages":[{"title":"关于作者","date":"un00fin00","updated":"un00fin00","comments":true,"path":"about/index.html","permalink":"http://zeco.oschina.io/about/index.html","excerpt":"","text":""},{"title":"标签云","date":"un00fin00","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"http://zeco.oschina.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"un11fin11","updated":"un11fin11","comments":true,"path":"categories/index.html","permalink":"http://zeco.oschina.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"好玩的ReidsCycle","slug":"rediscycle","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2016/05/16/rediscycle/","link":"","permalink":"http://zeco.oschina.io/2016/05/16/rediscycle/","excerpt":"最近，突发奇想的想要设计一个延时触发的项目，上网翻腾了一把，着实发现了不少有意思的东西，这里附上感觉不错的两处：一、二","text":"最近，突发奇想的想要设计一个延时触发的项目，上网翻腾了一把，着实发现了不少有意思的东西，这里附上感觉不错的两处：一、二 比较常见的方案使用cron定时任务，但是cron设定任务最低的精度到minute,某些时候，我们需要的可能是精确到second级别的定时计划。 再者，当表单数据量巨大时，使用cron进行轮询的效率就很低。 因为，每次轮询都要扫一次库，之前执行过的记录仍会被扫描，这样的效率就会下降 使用redis实现高效的延时设计参见一中的设计，这里包含两个重要的数据结构： 环形队列，一个头尾相接数组，其包含3600个slot的环形队列（一环设计为1h==60min==3600s，cycle=n?） work_ task, 置于指定时间点的 [‘set’=&gt;[cycle,dot,work_task]] timer, 一个和环形队列对应的timer是必须的,每当timer变化设定的dot值时，环形队列的指针（index）便移动一位，同事检测当前dot上的set集，对比集中cycle，如果对应上，便执行此点上的work_ task 这里我们设定一个例子： slot(3600,dot=1s) timer=dot=1s set=[task_1=&gt;[‘cycle’=&gt;3,’dot’=&gt;667,’task’=&gt;function(){echo ‘do it’}]] 任务执行的逻辑如下：123(cycle=1,dot=667)--&gt;1 != 3 &amp;&amp; 667 == 667 continue(cycle=2,dot=667)--&gt;2 != 3 &amp;&amp; 667 == 667 continue(cycle=3,dot=667)--&gt;3 == 3 &amp;&amp; 667 == 667 do work_task--&gt;echo do it--&gt;delete work_task 从任务的逻辑不难看出， 每次指针移动时，只需要查看当前dot上是否有set如果有set集则进行判断cycle值，决定是否执行任务，无需轮询全部任务，效率提升 每个订单任务被执行之后，即刻更新任务数据，一个任务只执行一次 时效性自定义，再不影响系统性能的情况下，就能够做到足够高的精确度","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zeco.oschina.io/categories/数据库/"},{"name":"nosql","slug":"数据库/nosql","permalink":"http://zeco.oschina.io/categories/数据库/nosql/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zeco.oschina.io/tagcloud/redis/"},{"name":"环形队列","slug":"环形队列","permalink":"http://zeco.oschina.io/tagcloud/环形队列/"},{"name":"延时设计","slug":"延时设计","permalink":"http://zeco.oschina.io/tagcloud/延时设计/"}]},{"title":"PHP+salt加密","slug":"php+salt","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2016/05/13/php+salt/","link":"","permalink":"http://zeco.oschina.io/2016/05/13/php+salt/","excerpt":"","text":"最近又听闻用户信息泄露的新闻，此前，作为it小白的时候，实在不知道怎么处理这样的变故，而泄漏的信息如果被黑客利用，通过撞库的方法就可破解大多数用户的密码，毕竟用户偏向于使用自己简单容易记住的密码，也不会多去改变他们，这时，如果我们开发人员还使用单一的加密方式，那是十分不明智的。 MD5加盐加密我们对md5()这个函数再是熟悉不过了，都使用过md5()对用户密码进行加密处理，这样做没有错，因为MD5加密不可逆，但是这样做的安全性还是很低的，因为很多网站的用户数据都是用md5进行加密处理的，而且网上也有许多人为整理出来的常用的MD5加密库，而从CSDN当时泄漏出来的用户信息来看，即便是作为与网络打交道的程序员，其中也有许多使用的是简单的密码组合，及其容易被匹配出来，再者，对于黑客而言，其破解密码手段通过撞库，简单的密码组合就大大增大了密码被破解的几率。 直接去开发一个新的算法来加密，从现实的角度是不实际的，那既然从算法的角度无法实现，那么我们就可以从入口的数据下手，将用户的密码添加一些佐料，这样即便是简单的密码，也会因为我们的加密，提升了密码组合的复杂程度，不会那么轻易的被破解，这就是所谓的加salt。 12345678910$salt = get_salt(SALT); //我们通过设置不同的SALT值来获取不同等级的加密$password = &apos;we2134sda&apos;; //用户处获取的明文密码$md5_password = md5(&apos;your_site&apos;.$password.$salt);//最终加密后密码function get_salt（$param） &#123; $salt = &apos;&apos;; for ($i = 0;$i &lt; $param; $i++) &#123; $salt .= chr(mt_rand(13,$param*12+13)); &#125; return $salt;&#125; 这里我们使用md5加随机生成的salt来增强加密后的密码安全性，然后我们记录下salt值，在用户注册的时候和密码一起生成并保存到数据库中，用户登录验证的时候再把密码和盐值一起组合验证，通过这样的手段就可以加强密码的安全性。","categories":[{"name":"安全","slug":"安全","permalink":"http://zeco.oschina.io/categories/安全/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://zeco.oschina.io/tagcloud/加密/"},{"name":"md5","slug":"md5","permalink":"http://zeco.oschina.io/tagcloud/md5/"}]},{"title":"用hexo+github搭建一个静态blog","slug":"your blog","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2016/05/03/your blog/","link":"","permalink":"http://zeco.oschina.io/2016/05/03/your blog/","excerpt":"关于怎么搭建blog的教程网上有一堆，挑一个比较详细的附上：如何搭建一个独立博客——简明Github Pages与Hexo教程这里就记录一些个人探过的一些小坑，以做前车之鉴。","text":"关于怎么搭建blog的教程网上有一堆，挑一个比较详细的附上：如何搭建一个独立博客——简明Github Pages与Hexo教程这里就记录一些个人探过的一些小坑，以做前车之鉴。 配置文件使用hexo搭建blog的时候系统默认了一个theme：landscape 我使用的是这个主题：ICARUS 下载之后要在主配置文件 _config.yaml里配置1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-icarus //你所下载的主题仓库名称 而如果需要调整请在主题文件夹的 _config.yaml里配置 注意两者的位置主配置文件位于hexo文件的根目录中主题配置文件的目录位于hexo-&gt;themes-&gt;(your themes)-&gt;_config.yaml(一般出事文件还有后缀example，将他去掉就好了) 部署到github使用$ hexo d 就可以将生成好的静态文件部署到github上，但部署文件之前需要在主配置文件里配置123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/yourgithubname/yourgithubname.github.io.git branch: master 注意，这里的仓库名称一定要是你的：github用户名.github.io才会被github默认为pages 但需要注意的是，有些时候这样的配置不一定能够成功，因为在hexo3里使用https:// 会影响他的部署这里要将仓库地址repo改成1repo：git@github.com:username/username.github.io.git 如果还是失败，那就要检查SSH key是否添加成功，以及git的设置是否成功 关于MarkDown的书写使用hexo new post [post title],可以生成一篇新的文章，只需要到/source/_post/下就可以找到生成的title.md文件下面是标题文件的书写123456---title: blog标题categories: [一级分类，二级分类...]tags: [标签1,标签2,标签3...]thumbnail: url of image(缩略图的路径)--- 博文正文的书写惨遭markdown语法，markdown语法兼容html的语法，相信对学习过html标签都不是一件难事。这里再提一点，如果需要只显示部分的博文可以使用1&lt;!--more--&gt; 来分割显示和不显示的文章 关于pluginhexo官网上有许多优秀的plugin，我找了一个比较有意思的标签云插件按照readme一步一步配置就可以实现动态的tagcloud了 最后上一切的起源：hexo","categories":[{"name":"blog","slug":"blog","permalink":"http://zeco.oschina.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://zeco.oschina.io/tagcloud/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://zeco.oschina.io/tagcloud/hexo/"},{"name":"github","slug":"github","permalink":"http://zeco.oschina.io/tagcloud/github/"}]},{"title":"MySQL (III) 字段类型选择","slug":"mysql_uh3","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2016/04/30/mysql_uh3/","link":"","permalink":"http://zeco.oschina.io/2016/04/30/mysql_uh3/","excerpt":"字段是组成一张表的最基本单元，但它们却是数据表设计时不得不严密考虑的部分，因为不恰当的字段类型选择，不仅容易造成数据库空间的浪费，以及冗余的产生，且在数据量巨大以及查询频繁的字段或表，将严重影响数据的读写速度。","text":"字段是组成一张表的最基本单元，但它们却是数据表设计时不得不严密考虑的部分，因为不恰当的字段类型选择，不仅容易造成数据库空间的浪费，以及冗余的产生，且在数据量巨大以及查询频繁的字段或表，将严重影响数据的读写速度。 Int（bigint，int，mediumint，smallint，tinyint）因为计算机本身只分辨数字型的数据，所以合理的使用整形字段可以提升数据读取的速度。 整形数据由大至小，从16个字节到1个字节不等，对于不同需求的表选择不同类型的int类型作为表的primary key是一个不错的选择。 这里还要提到的一点，虽然MySQL数据库提供了datetime类型的字段，但我们还是尽量以int类型的格式来存储时间戳的方法来保存时间数据，这样可以提高读取速度和减少I/O的开销。 在一些单选或者多选的字段里，也应当尽量避免使用枚举，适当的选用tinyint这样的短int数据是更好的选择。 Float（float，double，decimal）其实在浮点类型的数据中，decimal并不是作为数字存储在数据库中的，相反他是以我们’厌恶’的字符类型存在。 在这里，我们不得不来讨论一下浮点型数的一些缺点，单/双精度的数据类型在数据库中超过一定位数之后会出现失去精度的的情况，这个位数的大小在6位小数，而我们存储一些类似价格，额度等字段时，需要一种完全精确的记录，而decimal（65，30）如此长度的记录数完全满足我们的需求，这是浮点类型数据我们应当关心的部分。 字符（char，varchar）虽然字符类型的数据在读取时并不佳，但字符型的数据却是一个数据库不可忽略的部分。 char和varchar的不同体现在多个方面 1.char类型数据最大长度（255），而varchar类型数据的最大长度为（65535） 这里需要注意的是，varchar类型的数据长度存储的字节长度，即varchar类型的数据需要考虑编码的原因 2.两者最主要体现在两者侧重的方面不同，char类型数据属于定长数据，不论存储多少长度的数据，都占据一定的空间，而varchar数据则不论在表中设计多大的长度，都依照存储的字符串长度来决定占用的空间 3.因为varchar之所节省空间，是因为varchar经过了一层数据库的算法过滤，恰恰也是这层过滤，使得varchar类型的数据在读写速度上劣于char类型的数据。 总而言之，varchar和char两者，一个为了节省空间而浪费了时间，一个为了节省时间而浪费了空间，这就需要我们在设计表格的时候，谨慎的去考虑和取舍了。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zeco.oschina.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zeco.oschina.io/categories/数据库/mysql/"}],"tags":[{"name":"字段优化","slug":"字段优化","permalink":"http://zeco.oschina.io/tagcloud/字段优化/"}]},{"title":"Mysql (II) 引擎","slug":"mysql_uh2","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2016/04/21/mysql_uh2/","link":"","permalink":"http://zeco.oschina.io/2016/04/21/mysql_uh2/","excerpt":"这里，只简单的讨论两种常见的引擎：MyISAM和InnoDB的区别。","text":"这里，只简单的讨论两种常见的引擎：MyISAM和InnoDB的区别。 a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持. b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快. c. InnoDB不支持fulltext类型的索引. d. InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可. e. 对于auto_increment类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 f. delete from table时，InnoDB不会重新建立表，而是一行一行的删除。 g. load table from master操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用. h. MyISAM支持表锁，InnoDB支持行锁。 B-treeInnoDB的B-tree结构 如上图所示，InnoDB的搜索树由两层结构组成，每次对InnoDB引擎的表操作时，实际上是经过了两次的处理，先通过索引找到主键的位置，再获取对应主键的记录，这样不论是写入还是读取的速度都讲收到影响。 MyISAM的B-tree结构 MyISAM的结构决定了，每次读取和写入的时候不用考虑主键的顺序重排，所以MyISAM引擎的表的读取速度较InnoDB的快","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zeco.oschina.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zeco.oschina.io/categories/数据库/mysql/"}],"tags":[{"name":"数据库引擎","slug":"数据库引擎","permalink":"http://zeco.oschina.io/tagcloud/数据库引擎/"}]},{"title":"Mysql (I) 数据表设计规范","slug":"mysql_uh1","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2016/04/03/mysql_uh1/","link":"","permalink":"http://zeco.oschina.io/2016/04/03/mysql_uh1/","excerpt":"三范式&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。三范式的具体要求如下： 原子性（不可再分的字段） 非主键字段必须依赖主键 消除非主键之间的传递依赖","text":"三范式&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。三范式的具体要求如下： 原子性（不可再分的字段） 非主键字段必须依赖主键 消除非主键之间的传递依赖 &nbsp;&nbsp;&nbsp;&nbsp;当然，三范式在网上存在许多不同的版本，但不论是哪个版本的三范式，其中心思想都是一样的，那就是设计出比较合理的数据表，尽可能的减少代码的冗余。 但需要注意的是，代码的冗余只能减少，而不是消灭 具体设计思路如下： id name order order_name address weather price (非设计规范表) (拆分address字段保证设计表的原子性) -&gt; id name order order_name country province city weather price (将非主键依赖的weather的字段拆分出去) -&gt; id name order order_name country province city price (消除order和order_name之间的传递依赖，将非主键之间的传递依赖消除) -&gt; id name order country province city price 逆范式&nbsp;&nbsp;&nbsp;&nbsp;实际项目中，并不是完全按三范式的规范来设计表的结构，具体的项目中，逆范式的设计有时候可以简化sql的语句，提高sql语句的执行效率，此时逆范式的设计明显更有利于我们的项目，这个情况下使用逆范式的设计将更为科学。 例如，我们现在有两张表，一张分类表（category），一张商品表（goods），这里我们项目需要查询分类id、分类名称、商品数量三个字段，具体的sql语句如下：1select c.*,count(g.goods_id) goods_num from category as c left join goods as g on c.cat_id = g.cat_id group by c.cat_id; 可以看到，这个使用jion连表查询的sql语句相对于简单的表结构并不简单，而如果我们给分类表加上一个对应的商品数量字段，这样的sql语句将大大简化，这个时候我们大可不必严守三范式的设计思路，不妨使用逆范式的方式来设计这张表。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zeco.oschina.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zeco.oschina.io/categories/数据库/mysql/"}],"tags":[{"name":"表设计","slug":"表设计","permalink":"http://zeco.oschina.io/tagcloud/表设计/"}]}]}