<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[PHP+salt加密]]></title>
      <url>/2016/05/13/php+salt/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mima_1.bmp" alt=""><br><a id="more"></a><br>最近又听闻用户信息泄露的新闻，此前，作为it小白的时候，实在不知道怎么处理这样的变故，而泄漏的信息如果被黑客利用，通过撞库的方法就可破解大多数用户的密码，毕竟用户偏向于使用自己简单容易记住的密码，也不会多去改变他们，这时，如果我们开发人员还使用单一的加密方式，那是十分不明智的。</p>
<hr>
<h3 id="MD5加盐加密"><a href="#MD5加盐加密" class="headerlink" title="MD5加盐加密"></a>MD5加盐加密</h3><p>我们对md5()这个函数再是熟悉不过了，都使用过md5()对用户密码进行加密处理，这样做没有错，因为MD5加密不可逆，但是这样做的安全性还是很低的，因为很多网站的用户数据都是用md5进行加密处理的，而且网上也有许多人为整理出来的常用的MD5加密库，而从CSDN当时泄漏出来的用户信息来看，即便是作为与网络打交道的程序员，其中也有许多使用的是简单的密码组合，及其容易被匹配出来，再者，对于黑客而言，其破解密码手段通过撞库，简单的密码组合就大大增大了密码被破解的几率。</p>
<p>直接去开发一个新的算法来加密，从现实的角度是不实际的，那既然从算法的角度无法实现，那么我们就可以从入口的数据下手，将用户的密码添加一些佐料，这样即便是简单的密码，也会因为我们的加密，提升了密码组合的复杂程度，不会那么轻易的被破解，这就是所谓的加salt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$salt = get_salt(SALT); //我们通过设置不同的SALT值来获取不同等级的加密</div><div class="line">$password = &apos;we2134sda&apos;; //用户处获取的明文密码</div><div class="line">$md5_password = md5(&apos;your_site&apos;.$password.$salt);//最终加密后密码</div><div class="line">function get_salt（$param） &#123;</div><div class="line">	$salt = &apos;&apos;;</div><div class="line">	for ($i = 0;$i &lt; $param; $i++) &#123;</div><div class="line">		$salt .= chr(mt_rand(13,$param*12+13));</div><div class="line">	&#125;</div><div class="line">	return $salt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们使用md5加随机生成的salt来增强加密后的密码安全性，然后我们记录下salt值，在用户注册的时候和密码一起生成并保存到数据库中，用户登录验证的时候再把密码和盐值一起组合验证，通过这样的手段就可以加强密码的安全性。</p>
]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> md5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL (III) 字段类型选择]]></title>
      <url>/2016/04/30/mysql_uh3/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_4.bmp" alt=""><br>字段是组成一张表的最基本单元，但它们却是数据表设计时不得不严密考虑的部分，因为不恰当的字段类型选择，不仅容易造成数据库空间的浪费，以及冗余的产生，且在数据量巨大以及查询频繁的字段或表，将严重影响数据的读写速度。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="Int（bigint，int，mediumint，smallint，tinyint）"><a href="#Int（bigint，int，mediumint，smallint，tinyint）" class="headerlink" title="Int（bigint，int，mediumint，smallint，tinyint）"></a>Int（bigint，int，mediumint，smallint，tinyint）</h3><p>因为计算机本身只分辨数字型的数据，所以合理的使用整形字段可以提升数据读取的速度。</p>
<p>整形数据由大至小，从16个字节到1个字节不等，对于不同需求的表选择不同类型的int类型作为表的primary key是一个不错的选择。</p>
<p>这里还要提到的一点，虽然MySQL数据库提供了datetime类型的字段，但我们还是尽量以int类型的格式来存储时间戳的方法来保存时间数据，这样可以提高读取速度和减少I/O的开销。</p>
<p>在一些单选或者多选的字段里，也应当尽量避免使用枚举，适当的选用tinyint这样的短int数据是更好的选择。</p>
<hr>
<h3 id="Float（float，double，decimal）"><a href="#Float（float，double，decimal）" class="headerlink" title="Float（float，double，decimal）"></a>Float（float，double，decimal）</h3><p>其实在浮点类型的数据中，decimal并不是作为数字存储在数据库中的，相反他是以我们’厌恶’的字符类型存在。</p>
<p>在这里，我们不得不来讨论一下浮点型数的一些缺点，单/双精度的数据类型在数据库中超过一定位数之后会出现失去精度的的情况，这个位数的大小在6位小数，而我们存储一些类似价格，额度等字段时，需要一种完全精确的记录，而decimal（65，30）如此长度的记录数完全满足我们的需求，这是浮点类型数据我们应当关心的部分。</p>
<hr>
<h3 id="字符（char，varchar）"><a href="#字符（char，varchar）" class="headerlink" title="字符（char，varchar）"></a>字符（char，varchar）</h3><p>虽然字符类型的数据在读取时并不佳，但字符型的数据却是一个数据库不可忽略的部分。</p>
<p>char和varchar的不同体现在多个方面</p>
<p>1.char类型数据最大长度（255），而varchar类型数据的最大长度为（65535）</p>
<blockquote>
<p>这里需要注意的是，varchar类型的数据长度存储的字节长度，即varchar类型的数据需要考虑编码的原因</p>
</blockquote>
<p>2.两者最主要体现在两者侧重的方面不同，char类型数据属于定长数据，不论存储多少长度的数据，都占据一定的空间，而varchar数据则不论在表中设计多大的长度，都依照存储的字符串长度来决定占用的空间</p>
<p>3.因为varchar之所节省空间，是因为varchar经过了一层数据库的算法过滤，恰恰也是这层过滤，使得varchar类型的数据在读写速度上劣于char类型的数据。</p>
<p>总而言之，varchar和char两者，一个为了节省空间而浪费了时间，一个为了节省时间而浪费了空间，这就需要我们在设计表格的时候，谨慎的去考虑和取舍了。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字段优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (II) 引擎]]></title>
      <url>/2016/04/21/mysql_uh2/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_1.jpg" alt="Mysql示意图"><br>这里，只简单的讨论两种常见的引擎：<span style="color:green"><strong>MyISAM</strong></span>和<span style="color:red"><strong>InnoDB</strong></span>的区别。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.</p>
<p>b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.</p>
<p>c. InnoDB不支持fulltext类型的索引.</p>
<p>d. InnoDB 中不保存表的具体行数，也就是说，<br>执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，<br>但是MyISAM只要简单的读出保存好的行数即可.</p>
<p>e. 对于auto_increment类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>f. delete from table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>g. load table from master操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用.</p>
<p>h. MyISAM支持表锁，InnoDB支持行锁。</p>
<hr>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>InnoDB的B-tree结构<br><img src="/css/images/mysql_2.jpg" alt="InnoDB_B-tree"></p>
<blockquote>
<p>如上图所示，InnoDB的搜索树由两层结构组成，每次对InnoDB引擎的表操作时，实际上是经过了两次的处理，先通过索引找到主键的位置，再获取对应主键的记录，这样不论是写入还是读取的速度都讲收到影响。</p>
</blockquote>
<p>MyISAM的B-tree结构<br><img src="/css/images/mysql_3.jpg" alt="MyISAM_B-tree"></p>
<blockquote>
<p>MyISAM的结构决定了，每次读取和写入的时候不用考虑主键的顺序重排，所以MyISAM引擎的表的读取速度较InnoDB的快</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (I) 数据表设计规范]]></title>
      <url>/2016/04/03/mysql_uh1/</url>
      <content type="html"><![CDATA[<h4 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。<br>三范式的具体要求如下：</p>
<ol>
<li>原子性（不可再分的字段）</li>
<li>非主键字段必须依赖主键</li>
<li>消除非主键之间的传递依赖</li>
</ol>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当然，三范式在网上存在许多不同的版本，但不论是哪个版本的三范式，其中心思想都是一样的，那就是设计出比较合理的数据表，尽可能的<strong>减少代码的冗余</strong>。</p>
<blockquote>
<p>但需要注意的是，代码的冗余只能<strong>减少</strong>，而不是消灭</p>
</blockquote>
<p>具体设计思路如下：</p>
<pre><code>id name order order_name address weather price (非设计规范表)
(拆分address字段保证设计表的原子性)
-&gt; id name order order_name country province city weather price
(将非主键依赖的weather的字段拆分出去)
-&gt; id name order order_name country province city price
(消除order和order_name之间的传递依赖，将非主键之间的传递依赖消除)
-&gt; id name order country province city price
</code></pre><h3 id="逆范式"><a href="#逆范式" class="headerlink" title="逆范式"></a>逆范式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实际项目中，并不是完全按三范式的规范来设计表的结构，具体的项目中，逆范式的设计有时候可以简化sql的语句，提高sql语句的执行效率，此时逆范式的设计明显更有利于我们的项目，这个情况下使用逆范式的设计将更为科学。</p>
<p>例如，我们现在有两张表，一张分类表（category），一张商品表（goods），这里我们项目需要查询分类id、分类名称、商品数量三个字段，具体的sql语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select c.*,count(g.goods_id) goods_num from category as c left join goods as g on c.cat_id = g.cat_id group by c.cat_id;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个使用jion连表查询的sql语句相对于简单的表结构并不简单，而如果我们给分类表加上一个对应的商品数量字段，这样的sql语句将大大简化，这个时候我们大可不必严守三范式的设计思路，不妨使用逆范式的方式来设计这张表。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 表设计 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
