<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[LinuxCon引发的思考]]></title>
      <url>/2017/06/28/futrue_road/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/fuck_1.jpg" alt=""><br>2017年的夏天，LinuxCon第一次在中国召开，一年之前，我对这个消息一点反应也没有，现在却突兀的觉得有些触动，似乎某些不起眼的东西就发生在你身边，这世界上没有谁能知道这对未来代表了什么<a id="more"></a>，我不知道，你也不知道，但世间的事总是这样，不是等你准备好了再发生，而是有着它自己的规律，就那么生长着，盛放着，爆发着，然后死亡。</p>
<p>闲扯了一堆没头没脑的话，就像我近来混沌的头脑，里面填了一些东西，反倒不如当初清醒，不知道自己需要什么了。</p>
<p>然而，今天突然看到linus在和Dirk Hohndel的炉边谈话里的这么一句话</p>
<blockquote>
<p>For me, I was always self-motivated and knew what I wanted to do. I was never told what I should look at doing. I’m not sure my example is the right thing for people to follow. There are a ton of open source projects and, if you are a beginning programmer, find something you’re interested in that you can follow for more than just a few weeks. Get to know the code so well that you get to the point where you are an expert on a code piece. It doesn’t need to be the whole project. No one is an expert on the whole kernel, but you can know an area well.</p>
<p><span style="color:red">If you can be part of a community and set up patches, it’s not just about the coding, but about the social aspect of open source. You make connections and improve yourself as a programmer.</span> You are basically showing off – I made these improvements, I’m capable of going far in my community or job. You’ll have to spend a certain amount of time to learn a project, but there’s a huge upside – not just from a career aspect, but having an amazing project in your life.</p>
</blockquote>
<p>对于其中it’s not just about the coding，you make connections 这两句话话，感触尤深。</p>
<p>毫无波澜的工作生活往往让我们忘记一些东西，有些时候我们通过游戏，狂欢来消磨忘记它们，但这世界上最稳固的东西就是我们每天都要面对的日出日落，不论怎么逃避，他就在那里等着你回去，等着你去面对他。</p>
<p>我也模糊的明晰了自己所需要的东西，我不需要在每一个方面做得完美，但需要在某一个方面，做到令自己自豪的成绩，最后，一句话送给自己和看到这篇文章的你，<span style="color:green">the day and night, not only for small life,but for a gaint soul.</span></p>
]]></content>
      
        <categories>
            
            <category> 闲扯 </category>
            
            <category> 职业思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> about futrue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四种基本的排序算法学习总结]]></title>
      <url>/2017/06/23/algorithm_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/algorithm_1.jpg" alt=""><br>都说算法是程序的核心,但是作为一个半路出家的程序员，情不自禁的有点畏惧这个东西，但是今天却被教训了一顿，因为亲眼目睹前辈以一个简单的排序方法提升了好几倍的查询速度，好吧，决心一点点的啃下算法的硬骨头，提升一点自己coding的视野和高度。<br><a id="more"></a></p>
<h2 id="今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。"><a href="#今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。" class="headerlink" title="今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。"></a>今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>对一个乱序的数组，每次选择一个指定位置的元素（一般是第一个），每次scan，将被选择的元素作为基准，将乱序的数组分为大小两部分，后续递归剩下的部分，直到分割出来的数组长度不可再分。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function quick_sort($arr) &#123; </div><div class="line">	$length = count($arr); </div><div class="line">	if($length &lt;= 1) &#123; //递归出口</div><div class="line">		return $arr; </div><div class="line">	&#125; </div><div class="line">	$base_array = $arr[0]; //选择第一个元素作为基准 </div><div class="line">	//初始化两个数组,保证每次递归签数组清空</div><div class="line">	$left_array = array();  //小于基准的 </div><div class="line">	$right_array = array();  //大于基准的 </div><div class="line">	for($i=1; $i&lt;$length; $i++) &#123; </div><div class="line">		if($base_num &gt; $arr[$i]) &#123;//放入左边数组  </div><div class="line">			$left_array[] = $arr[$i]; </div><div class="line">		&#125; else &#123; //放入右边 </div><div class="line">			$right_array[] = $arr[$i]; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	//递归排序</div><div class="line">	$left_array = quick_sort($left_array); </div><div class="line">	$right_array = quick_sort($right_array); </div><div class="line">	//合并数组 </div><div class="line">	return array_merge($left_array, array($base_num), $right_array); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序基本是一个programer要学习的第一个算法，但是简单不代表他真的就low，就像递归和迭代算法一样，并没有那个算法是最优的，而是适当的环境下选择适当的算法。冒泡算法，通过两层循环，从第一个元素开始，每次对比相邻的元素，依据他们的大小和需要的排序决定他们的位置，最后获得一个重新排序过的数组。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function bubbleSort($arr)&#123; </div><div class="line">  $len=count($arr); </div><div class="line">  for($i=1;$i&lt;$len;$i++) &#123; //第一层循环控制层数  </div><div class="line">    for($k=0;$k&lt;$len-$i;$k++)&#123; //第二层循环用来控制级数</div><div class="line">       if($arr[$k]&gt;$arr[$k+1])&#123;</div><div class="line">            $tmp=$arr[$k+1]; </div><div class="line">            $arr[$k+1]=$arr[$k]; </div><div class="line">            $arr[$k]=$tmp; </div><div class="line">       &#125; </div><div class="line">    &#125; </div><div class="line">  &#125; </div><div class="line">  return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是通过假设一个假值，然后获得这个假值的位置（每次选择最大或者最小的树），寻找到他的位置，排列出一个固定顺序的数组。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function selectSort($arr) &#123; </div><div class="line">	//双重循环完成，外层控制轮数，内层控制比较次数 </div><div class="line">	$len=count($arr); </div><div class="line">	for($i=0; $i&lt;$len-1; $i++) &#123; </div><div class="line">		//假设最小的值的位置 </div><div class="line">		$p = $i; </div><div class="line">		for($j=$i+1; $j&lt;$len; $j++) &#123; </div><div class="line">			//比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。</div><div class="line">			if($arr[$p] &gt; $arr[$j]) &#123;  </div><div class="line">			$p = $j; </div><div class="line">			&#125; </div><div class="line">		&#125; </div><div class="line">		//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。 </div><div class="line">		if($p != $i) &#123; </div><div class="line">			$tmp = $arr[$p]; </div><div class="line">			$arr[$p] = $arr[$i]; </div><div class="line">			$arr[$i] = $tmp; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	//返回最终结果 </div><div class="line">	return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>假设一个数组是有序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function insertSort($arr) &#123; </div><div class="line">	$len=count($arr); </div><div class="line">	for($i=1, $i&lt;$len; $i++) &#123; </div><div class="line">		$tmp = $arr[$i]; </div><div class="line">		//内层循环控制，比较并插入 </div><div class="line">		for($j=$i-1;$j&gt;=0;$j--) &#123; </div><div class="line">			if($tmp &lt; $arr[$j]) &#123; </div><div class="line">				//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 </div><div class="line">				$arr[$j+1] = $arr[$j]; </div><div class="line">				$arr[$j] = $tmp; </div><div class="line">			&#125; else &#123; </div><div class="line">				//如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。 </div><div class="line">				break; </div><div class="line">			&#125; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git操作(I) 提交到远程仓库]]></title>
      <url>/2016/05/27/git_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/git_1.jpg" alt=""><br>目前市面有许多第三方git操作软件，比如我曾经用过的<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a>，就是一款上手和使用起来都不错的工具，但时间一长，总觉得差点微妙的feel，于是又灰溜溜的决定把命令行捡回来，写个系列的使用记录。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="创建一个本地仓库"><a href="#创建一个本地仓库" class="headerlink" title="创建一个本地仓库"></a>创建一个本地仓库</h3><ol>
<li>现在，有一个尚未开始的项目，那么进入你项目存放的目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd XXX</div><div class="line">$ git init</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样你就获得了一个仓库，并且处于当前<span style="color:green">master branch</span>上</p>
<ol>
<li>或者通过clone一个远程的仓库到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd XXX</div><div class="line">$ git clone url:repositories [repo&apos;s name]</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>需要注意的是，这个本地文件夹（<span style="color:red">XXX</span>）要是一个空的文件夹，否则会报错</p>
</blockquote>
<hr>
<h3 id="完成文件提交"><a href="#完成文件提交" class="headerlink" title="完成文件提交"></a>完成文件提交</h3><ol>
<li>创建一个本地文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim ./hello_git.md</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在文件输入你想加入的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ hello git :)</div></pre></td></tr></table></figure></p>
<p>保存后退出</p>
<ol>
<li>添加文件到暂存区，提交文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">使用</div><div class="line">$ git status</div><div class="line">查看当前文件状态，出现未添加文件，使用</div><div class="line">$ git add ./hello_git.md</div><div class="line">再查看文件状态‘</div><div class="line">$ git status</div><div class="line">这里显示文件暂存，然后准备commit</div><div class="line">$ git commit -m &apos;备注信息&apos;</div><div class="line">再次查看工作区时，显示tree clean，说明提交成功</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>你也可以使用 git status -s 命令查看更为详细的状态<br>也可以通过 git log 来查看每次commit</p>
</blockquote>
<hr>
<h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>git 属于分布式版本控制系统,每个电脑就相当于一个仓库，但如果你有一个geek的心，你可以将你的代码分享到一个远程的托管系统上，其中的代表有世界上最大的同性交友网站<a href="https://github.com/" target="_blank" rel="external">github</a>，还有国内的两个不错的托管平台<a href="https://coding.net/" target="_blank" rel="external">coding</a>和<a href="https://git.oschina.net/" target="_blank" rel="external">码云</a>。</p>
<p>我们可以通过remote命令将自己的代码托管在远程的代码托管平台上</p>
<ol>
<li>查看关联的远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
</li>
</ol>
<p>获得已经关联的远程仓库<br>2 . 配置本地账户信息<br>配置一个本地的用户信息，使得仓库中的操作是由谁做出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your_username&quot;  </div><div class="line">$ git config --global user.email your_email@domain.com</div></pre></td></tr></table></figure></p>
<ol>
<li>生成ssh秘钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your_email@domain.com&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输入命令之后会提示三次确认，一直回车确定，最后提示创建成功，然后进入主文件查看生成的id_rsa和id_rsa.pub，将id_rsa.pub公钥打开，添加到远程创建的长裤中</p>
<blockquote>
<p>打开公钥使用编辑器，否则可能会影响编码，导致添加失败</p>
</blockquote>
<ol>
<li>添加远程仓库地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin https://your_username@bitbucket.org/your_username/name_of_remote_repository.git </div><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显示push成功之后，就可以再远程仓库里看到你提交的代码了</p>
<blockquote>
<p>如果使用的clone仓库，那么本地默认存在远程仓库地址，只需要添加ssh公钥认证之后就可以提交代码到远程仓库了</p>
</blockquote>
<hr>
<p>如果你看了这些还是不太了解提交的过程，可以参考git官方给出的<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">操作book</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[好玩的ReidsCycle]]></title>
      <url>/2016/05/16/rediscycle/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/yanshi_1.bmp" alt=""><br>最近，突发奇想的想要设计一个延时触发的项目，上网翻腾了一把，着实发现了不少有意思的东西，这里附上感觉不错的两处：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959961&idx=1&sn=afec02c8dc6db9445ce40821b5336736&scene=0#wechat_redirect" target="_blank" rel="external">一</a>、<a href="https://github.com/chaiyue/delayed" target="_blank" rel="external">二</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="比较常见的方案"><a href="#比较常见的方案" class="headerlink" title="比较常见的方案"></a>比较常见的方案</h3><p>使用cron定时任务，但是cron设定任务最低的<span style="color:red">精度</span>到<span style="color:blue">minute</span>,某些时候，我们需要的可能是精确到<span style="color:blue">second</span>级别的定时计划。</p>
<p>再者，当表单数据量巨大时，使用cron进行轮询的效率就很低。</p>
<blockquote>
<p>因为，每次轮询都要扫一次库，之前执行过的记录仍会被扫描，这样的效率就会下降</p>
</blockquote>
<hr>
<h3 id="使用redis实现高效的延时设计"><a href="#使用redis实现高效的延时设计" class="headerlink" title="使用redis实现高效的延时设计"></a>使用redis实现高效的延时设计</h3><p>参见<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959961&idx=1&sn=afec02c8dc6db9445ce40821b5336736&scene=0#wechat_redirect" target="_blank" rel="external">一</a>中的设计，这里包含两个重要的数据结构：</p>
<blockquote>
<ol>
<li><span style="color:red">环形队列</span>，一个头尾相接数组，其包含3600个slot的环形队列（一环设计为1h==60min==3600s，cycle=n?）</li>
<li><span style="color:red">work_ task</span>, 置于指定时间点的 [‘set’=&gt;[cycle,dot,work_task]]</li>
<li><span style="color:red">timer</span>, 一个和环形队列对应的timer是必须的,每当timer变化设定的dot值时，环形队列的指针（index）便移动一位，同事检测当前dot上的set集，对比集中cycle，如果对应上，便执行此点上的work_ task</li>
</ol>
</blockquote>
<p>这里我们设定一个例子：</p>
<ol>
<li>slot(3600,dot=1s)</li>
<li>timer=dot=1s</li>
<li>set=[task_1=&gt;[‘cycle’=&gt;3,’dot’=&gt;667,’task’=&gt;function(){echo ‘do it’}]]</li>
</ol>
<p>任务执行的逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(cycle=1,dot=667)--&gt;1 != 3 &amp;&amp; 667 == 667 continue</div><div class="line">(cycle=2,dot=667)--&gt;2 != 3 &amp;&amp; 667 == 667 continue</div><div class="line">(cycle=3,dot=667)--&gt;3 == 3 &amp;&amp; 667 == 667 do work_task--&gt;echo do it--&gt;delete work_task</div></pre></td></tr></table></figure></p>
<p>从任务的逻辑不难看出，</p>
<ol>
<li>每次指针移动时，只需要查看当前dot上是否有set如果有set集则进行判断cycle值，决定是否执行任务，无需轮询全部任务，效率提升</li>
<li>每个订单任务被执行之后，即刻更新任务数据，一个任务只执行一次</li>
<li>时效性自定义，再不影响系统性能的情况下，就能够做到足够高的精确度</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> nosql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 环形队列 </tag>
            
            <tag> 延时设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP+salt加密]]></title>
      <url>/2016/05/13/php+salt/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mima_1.bmp" alt=""><br><a id="more"></a><br>最近又听闻用户信息泄露的新闻，此前，作为it小白的时候，实在不知道怎么处理这样的变故，而泄漏的信息如果被黑客利用，通过撞库的方法就可破解大多数用户的密码，毕竟用户偏向于使用自己简单容易记住的密码，也不会多去改变他们，这时，如果我们开发人员还使用单一的加密方式，那是十分不明智的。</p>
<hr>
<h3 id="MD5加盐加密"><a href="#MD5加盐加密" class="headerlink" title="MD5加盐加密"></a>MD5加盐加密</h3><p>我们对md5()这个函数再是熟悉不过了，都使用过md5()对用户密码进行加密处理，这样做没有错，因为MD5加密不可逆，但是这样做的安全性还是很低的，因为很多网站的用户数据都是用md5进行加密处理的，而且网上也有许多人为整理出来的常用的MD5加密库，而从CSDN当时泄漏出来的用户信息来看，即便是作为与网络打交道的程序员，其中也有许多使用的是简单的密码组合，及其容易被匹配出来，再者，对于黑客而言，其破解密码手段通过撞库，简单的密码组合就大大增大了密码被破解的几率。</p>
<p>直接去开发一个新的算法来加密，从现实的角度是不实际的，那既然从算法的角度无法实现，那么我们就可以从入口的数据下手，将用户的密码添加一些佐料，这样即便是简单的密码，也会因为我们的加密，提升了密码组合的复杂程度，不会那么轻易的被破解，这就是所谓的加salt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$salt = get_salt(SALT); //我们通过设置不同的SALT值来获取不同等级的加密</div><div class="line">$password = &apos;we2134sda&apos;; //用户处获取的明文密码</div><div class="line">$md5_password = md5(&apos;your_site&apos;.$password.$salt);//最终加密后密码</div><div class="line">function get_salt（$param） &#123;</div><div class="line">	$salt = &apos;&apos;;</div><div class="line">	for ($i = 0;$i &lt; $param; $i++) &#123;</div><div class="line">		$salt .= chr(mt_rand(13,$param*12+13));</div><div class="line">	&#125;</div><div class="line">	return $salt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们使用md5加随机生成的salt来增强加密后的密码安全性，然后我们记录下salt值，在用户注册的时候和密码一起生成并保存到数据库中，用户登录验证的时候再把密码和盐值一起组合验证，通过这样的手段就可以加强密码的安全性。</p>
]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> md5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用hexo+github搭建一个静态blog]]></title>
      <url>/2016/05/03/your%20blog/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/blog_1.jpg" alt=""><br>关于怎么搭建blog的教程网上有一堆，挑一个比较详细的附上：<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>这里就记录一些个人探过的一些小坑，以做前车之鉴。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>使用hexo搭建blog的时候系统默认了一个theme：landscape</p>
<p>我使用的是这个主题：<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external">ICARUS</a></p>
<p>下载之后要在主配置文件 _config.yaml里配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: hexo-theme-icarus //你所下载的主题仓库名称</div></pre></td></tr></table></figure></p>
<p>而如果需要调整请在主题文件夹的 _config.yaml里配置</p>
<blockquote>
<p>注意两者的位置<br>主配置文件位于hexo文件的根目录中<br>主题配置文件的目录位于hexo-&gt;themes-&gt;(your themes)-&gt;_config.yaml(一般出事文件还有后缀example，将他去掉就好了)</p>
</blockquote>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>使用<span style="color:green;font-size:20px">$ hexo d</span> 就可以将生成好的静态文件部署到github上，但部署文件之前需要在主配置文件里配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line"> 		type: git</div><div class="line"> 		repo: https://github.com/yourgithubname/yourgithubname.github.io.git</div><div class="line"> 		branch: master</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，这里的仓库名称一定要是你的：github用户名.github.io才会被github默认为pages</p>
</blockquote>
<p>但需要注意的是，有些时候这样的配置不一定能够成功，因为在hexo3里使用<span style="color:red">https://</span> 会影响他的部署<br>这里要将仓库地址repo改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo：git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>
<p>如果还是失败，那就要检查SSH key是否添加成功，以及git的设置是否成功</p>
<h3 id="关于MarkDown的书写"><a href="#关于MarkDown的书写" class="headerlink" title="关于MarkDown的书写"></a>关于MarkDown的书写</h3><p>使用hexo new post [post title],可以生成一篇新的文章，只需要到<span style="color:purple">/source/_post/</span>下就可以找到生成的title.md文件<br>下面是标题文件的书写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: blog标题</div><div class="line">categories: [一级分类，二级分类...]</div><div class="line">tags: [标签1,标签2,标签3...]</div><div class="line">thumbnail: url of image(缩略图的路径)</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>博文正文的书写惨遭markdown语法，markdown语法兼容html的语法，相信对学习过html标签都不是一件难事。<br>这里再提一点，如果需要只显示部分的博文可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!--more--&gt;</div></pre></td></tr></table></figure></p>
<p>来分割显示和不显示的文章</p>
<h3 id="关于plugin"><a href="#关于plugin" class="headerlink" title="关于plugin"></a>关于plugin</h3><p>hexo官网上有许多优秀的plugin，我找了一个比较有意思的<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="external">标签云插件</a><br>按照readme一步一步配置就可以实现动态的tagcloud了</p>
<p>最后上一切的起源：<a href="https://hexo.io/" target="_blank" rel="external">hexo</a></p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL (III) 字段类型选择]]></title>
      <url>/2016/04/30/mysql_uh3/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_4.bmp" alt=""><br>字段是组成一张表的最基本单元，但它们却是数据表设计时不得不严密考虑的部分，因为不恰当的字段类型选择，不仅容易造成数据库空间的浪费，以及冗余的产生，且在数据量巨大以及查询频繁的字段或表，将严重影响数据的读写速度。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="Int（bigint，int，mediumint，smallint，tinyint）"><a href="#Int（bigint，int，mediumint，smallint，tinyint）" class="headerlink" title="Int（bigint，int，mediumint，smallint，tinyint）"></a>Int（bigint，int，mediumint，smallint，tinyint）</h3><p>因为计算机本身只分辨数字型的数据，所以合理的使用整形字段可以提升数据读取的速度。</p>
<p>整形数据由大至小，从16个字节到1个字节不等，对于不同需求的表选择不同类型的int类型作为表的primary key是一个不错的选择。</p>
<p>这里还要提到的一点，虽然MySQL数据库提供了datetime类型的字段，但我们还是尽量以int类型的格式来存储时间戳的方法来保存时间数据，这样可以提高读取速度和减少I/O的开销。</p>
<p>在一些单选或者多选的字段里，也应当尽量避免使用枚举，适当的选用tinyint这样的短int数据是更好的选择。</p>
<hr>
<h3 id="Float（float，double，decimal）"><a href="#Float（float，double，decimal）" class="headerlink" title="Float（float，double，decimal）"></a>Float（float，double，decimal）</h3><p>其实在浮点类型的数据中，decimal并不是作为数字存储在数据库中的，相反他是以我们’厌恶’的字符类型存在。</p>
<p>在这里，我们不得不来讨论一下浮点型数的一些缺点，单/双精度的数据类型在数据库中超过一定位数之后会出现失去精度的的情况，这个位数的大小在6位小数，而我们存储一些类似价格，额度等字段时，需要一种完全精确的记录，而decimal（65，30）如此长度的记录数完全满足我们的需求，这是浮点类型数据我们应当关心的部分。</p>
<hr>
<h3 id="字符（char，varchar）"><a href="#字符（char，varchar）" class="headerlink" title="字符（char，varchar）"></a>字符（char，varchar）</h3><p>虽然字符类型的数据在读取时并不佳，但字符型的数据却是一个数据库不可忽略的部分。</p>
<p>char和varchar的不同体现在多个方面</p>
<p>1.char类型数据最大长度（255），而varchar类型数据的最大长度为（65535）</p>
<blockquote>
<p>这里需要注意的是，varchar类型的数据长度存储的字节长度，即varchar类型的数据需要考虑编码的原因</p>
</blockquote>
<p>2.两者最主要体现在两者侧重的方面不同，char类型数据属于定长数据，不论存储多少长度的数据，都占据一定的空间，而varchar数据则不论在表中设计多大的长度，都依照存储的字符串长度来决定占用的空间</p>
<p>3.因为varchar之所节省空间，是因为varchar经过了一层数据库的算法过滤，恰恰也是这层过滤，使得varchar类型的数据在读写速度上劣于char类型的数据。</p>
<p>总而言之，varchar和char两者，一个为了节省空间而浪费了时间，一个为了节省时间而浪费了空间，这就需要我们在设计表格的时候，谨慎的去考虑和取舍了。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字段优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (II) 引擎]]></title>
      <url>/2016/04/21/mysql_uh2/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_1.jpg" alt="Mysql示意图"><br>这里，只简单的讨论两种常见的引擎：<span style="color:green"><strong>MyISAM</strong></span>和<span style="color:red"><strong>InnoDB</strong></span>的区别。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.</p>
<p>b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.</p>
<p>c. InnoDB不支持fulltext类型的索引.</p>
<p>d. InnoDB 中不保存表的具体行数，也就是说，<br>执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，<br>但是MyISAM只要简单的读出保存好的行数即可.</p>
<p>e. 对于auto_increment类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>f. delete from table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>g. load table from master操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用.</p>
<p>h. MyISAM支持表锁，InnoDB支持行锁。</p>
<hr>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>InnoDB的B-tree结构<br><img src="/css/images/mysql_2.jpg" alt="InnoDB_B-tree"></p>
<blockquote>
<p>如上图所示，InnoDB的搜索树由两层结构组成，每次对InnoDB引擎的表操作时，实际上是经过了两次的处理，先通过索引找到主键的位置，再获取对应主键的记录，这样不论是写入还是读取的速度都讲收到影响。</p>
</blockquote>
<p>MyISAM的B-tree结构<br><img src="/css/images/mysql_3.jpg" alt="MyISAM_B-tree"></p>
<blockquote>
<p>MyISAM的结构决定了，每次读取和写入的时候不用考虑主键的顺序重排，所以MyISAM引擎的表的读取速度较InnoDB的快</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (I) 数据表设计规范]]></title>
      <url>/2016/04/03/mysql_uh1/</url>
      <content type="html"><![CDATA[<h4 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。<br>三范式的具体要求如下：</p>
<ol>
<li>原子性（不可再分的字段）</li>
<li>非主键字段必须依赖主键</li>
<li>消除非主键之间的传递依赖</li>
</ol>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当然，三范式在网上存在许多不同的版本，但不论是哪个版本的三范式，其中心思想都是一样的，那就是设计出比较合理的数据表，尽可能的<strong>减少代码的冗余</strong>。</p>
<blockquote>
<p>但需要注意的是，代码的冗余只能<strong>减少</strong>，而不是消灭</p>
</blockquote>
<p>具体设计思路如下：</p>
<pre><code>id name order order_name address weather price (非设计规范表)
(拆分address字段保证设计表的原子性)
-&gt; id name order order_name country province city weather price
(将非主键依赖的weather的字段拆分出去)
-&gt; id name order order_name country province city price
(消除order和order_name之间的传递依赖，将非主键之间的传递依赖消除)
-&gt; id name order country province city price
</code></pre><h3 id="逆范式"><a href="#逆范式" class="headerlink" title="逆范式"></a>逆范式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实际项目中，并不是完全按三范式的规范来设计表的结构，具体的项目中，逆范式的设计有时候可以简化sql的语句，提高sql语句的执行效率，此时逆范式的设计明显更有利于我们的项目，这个情况下使用逆范式的设计将更为科学。</p>
<p>例如，我们现在有两张表，一张分类表（category），一张商品表（goods），这里我们项目需要查询分类id、分类名称、商品数量三个字段，具体的sql语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select c.*,count(g.goods_id) goods_num from category as c left join goods as g on c.cat_id = g.cat_id group by c.cat_id;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个使用jion连表查询的sql语句相对于简单的表结构并不简单，而如果我们给分类表加上一个对应的商品数量字段，这样的sql语句将大大简化，这个时候我们大可不必严守三范式的设计思路，不妨使用逆范式的方式来设计这张表。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 表设计 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
