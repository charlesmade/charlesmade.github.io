<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[LinuxCon引发的思考]]></title>
      <url>/2017/06/28/futrue_road/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/fuck_1.jpg" alt=""><br>2017年的夏天，LinuxCon第一次在中国召开，一年之前，我对这个消息一点反应也没有，现在却突兀的觉得有些触动，似乎某些不起眼的东西就发生在你身边，这世界上没有谁能知道这对未来代表了什么<a id="more"></a>，我不知道，你也不知道，但世间的事总是这样，不是等你准备好了再发生，而是有着它自己的规律，就那么生长着，盛放着，爆发着，然后死亡。</p>
<p>闲扯了一堆没头没脑的话，就像我近来混沌的头脑，里面填了一些东西，反倒不如当初清醒，不知道自己需要什么了。</p>
<p>然而，今天突然看到linus在和Dirk Hohndel的炉边谈话里的这么一句话</p>
<blockquote>
<p>For me, I was always self-motivated and knew what I wanted to do. I was never told what I should look at doing. I’m not sure my example is the right thing for people to follow. There are a ton of open source projects and, if you are a beginning programmer, find something you’re interested in that you can follow for more than just a few weeks. Get to know the code so well that you get to the point where you are an expert on a code piece. It doesn’t need to be the whole project. No one is an expert on the whole kernel, but you can know an area well.</p>
<p><span style="color:red">If you can be part of a community and set up patches, it’s not just about the coding, but about the social aspect of open source. You make connections and improve yourself as a programmer.</span> You are basically showing off – I made these improvements, I’m capable of going far in my community or job. You’ll have to spend a certain amount of time to learn a project, but there’s a huge upside – not just from a career aspect, but having an amazing project in your life.</p>
</blockquote>
<p>对于其中it’s not just about the coding，you make connections 这两句话话，感触尤深。</p>
<p>毫无波澜的工作生活往往让我们忘记一些东西，有些时候我们通过游戏，狂欢来消磨忘记它们，但这世界上最稳固的东西就是我们每天都要面对的日出日落，不论怎么逃避，他就在那里等着你回去，等着你去面对他。</p>
<p>我也模糊的明晰了自己所需要的东西，我不需要在每一个方面做得完美，但需要在某一个方面，做到令自己自豪的成绩，最后，一句话送给自己和看到这篇文章的你，<span style="color:green">the day and night, not only for small life,but for a gaint soul.</span></p>
]]></content>
      
        <categories>
            
            <category> 闲扯 </category>
            
            <category> 职业思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> about futrue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP 性能分析与实验：性能的宏观分析[转]]]></title>
      <url>/2017/04/05/php_1/</url>
      <content type="html"><![CDATA[<p>对 PHP 性能的分析，我们从两个层面着手，把这篇文章也分成了两个部分，一个是宏观层面，所谓宏观层面，就是 PHP 语言本身和环境层面，一个是应用层面，就是语法和使用规则的层面，不过不仅探讨规则，更辅助以示例的分析。</p>
<p>宏观层面，也就是对 PHP 语言本身的性能分析又分为三个方面：</p>
<ol>
<li>PHP 作为解释性语言性能有其天然的缺陷</li>
<li>PHP 作为动态类型语言在性能上也有提升的空间</li>
<li>当下主流 PHP 版本本身语言引擎性能<a id="more"></a>
</li>
</ol>
<hr>
<h3 id="PHP-作为解释性语言的性能分析与提升"><a href="#PHP-作为解释性语言的性能分析与提升" class="headerlink" title="PHP 作为解释性语言的性能分析与提升"></a>PHP 作为解释性语言的性能分析与提升</h3><p>PHP 作为一门脚本语言，也是解释性语言，是其天然性能受限的原因，因为同编译型语言在运行之前编译成二进制代码不同，解释性语言在每一次运行都面对原始脚本的输入、解析、编译，然后执行。如下是 PHP 作为解释性语言的执行过程。<br><img src="/css/images/php_1.png" alt=""><br>如上所示，从上图可以看到，每一次运行，都需要经历三个解析、编译、运行三个过程。</p>
<p>那优化的点在哪里呢？可以想见，只要代码文件确定，解析到编译这一步都是确定的，因为文件已不再变化，而执行，则由于输入参数的不同而不同。在性能优化的世界里，至上绝招就是在获得同样结果的情况下，减少操作，这就是大名鼎鼎的缓存。缓存无处不在，缓存也是性能优化的杀手锏。于是乎 OpCode 缓存这一招就出现了，只有第一次需要解析和编译，而在后面的执行中，直接由脚本到 Opcode，从而实现了性能提速。执行流程如下图所示：<br><img src="/css/images/php_2.png" alt=""><br>相对每一次解析、编译，读到脚本之后，直接从缓存读取字节码的效率会有大幅度的提升，提升幅度到底有多大呢？</p>
<p>我们来做一个没有 Opcode 缓存的实验。20 个并发，总共 10000 次请求没有经过 opcode 缓存的请求，，得到如下结果：<br><img src="/css/images/php_3.png" alt=""><br>其次，我们在服务器上打开 Opcode 缓存。要想实现 opcode 缓存，只需要安装 APC、Zend OPCache、eAccelerator 扩展即可，即使安装了多个，也只启用其中一个。注意的是，修改了 php.ini 配置之后，需要重新加载 php-fpm 的配置。</p>
<p>这里分别启用 APC 和 Zend OPCache 做实验。启用 APC 的版本。<br><img src="/css/images/php_4.png" alt=""><br>从上面的这个实验可以看到，所用的测试页面，有 40ms 以上的时间花在了语法解析和编译这两项上。通过将这两个操作缓存，可以将这个处理过程的速度大大提升。</p>
<p>这里附加补充一下，OpCode 到底是什么东东，OpCode 编译之后的字节码，我们可以使用bytekit 这样的工具，或者使用 vld PHP 扩展来实现对 PHP 的代码编译。如下是 vld 插件解析代码的运行结果。<br><img src="/css/images/php_5.png" alt=""><br>可以看到每一行代码被编译成相应的 OpCode 的输出。</p>
<hr>
<p>第二个是 PHP 语言是动态类型的语言，动态类型的语言本身由于涉及到在内存中的类型推断，比如在 PHP 中，两个整数相加，我们能得到整数值，一个整数和一个字符串相加，甚至两个字符串相加，都变成整数相加。而字符串和任何类型连接操作都成了字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 10.11;</div><div class="line">$b = &quot;30&quot;;</div><div class="line">var_dump($a+$b);</div><div class="line">var_dump(&quot;10&quot;+$b);</div><div class="line">var_dump(10+&quot;20&quot;);</div><div class="line">var_dump(&quot;10&quot;+&quot;20&quot;);</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">float(40.11)</div><div class="line">int(40)</div><div class="line">int(30)</div><div class="line">int(30)</div></pre></td></tr></table></figure></p>
<p>语言的动态类型为开发者提供了方便，语言本身则会因为动态类型而降低效率。在 Swift 中，有一个特性叫类型推断，我们可以看看类型推断会带来多大的一个效率上的差别呢？对于需要类型推断与不需要类型推断两段 Swift 代码，我们尝试编译一下看看效果如何。 第一段代码如下：<br><img src="/css/images/php_6.png" alt=""><br>这是一段 Swift 代码，字典只有 14 个键值对，这段代码的编译，9 分钟了还没有编译完成（5G 内存，2.4GHz CPU），编译环境为 Swift 1.2，Xcode 6.4。<br><img src="/css/images/php_7.png" alt=""><br>但是如果调整代码如下：<br><img src="/css/images/php_8.png" alt=""><br>也就是加上了类型限定，避免了 planeLocation 的类型推断。编译过程花了 2S 。<br><img src="/css/images/php_9.png" alt=""><br>可见，作为动态类型附加的类型推断操作极大地降低了程序的编译速度。 当然，这个例子有点极端，用 Swift 来类比 PHP 也不一定合适，因为 Swift 语言本身也还在不断的进化过程中。本例子只是表明在编程语言中，如果是动态类型语言，就涉及到对动态类型的处理，从编译的角度讲是会受影响的。</p>
<p>那么作为动态类型的 PHP 的效率如何提升呢？从 PHP 语言本身这个层面是没有办法解决的，因为你怎么写也是动态类型的代码。解决办法就是将PHP转化为静态类型的表示，也就是做成扩展，可以看到，鸟哥的很多项目，比如 Yaf 框架，都是做成了扩展的，当然这也是由于鸟哥是 C 高手。扩展由于是 C 或者 C++ 而写，所以不再是动态类型，又加之是编译好的，而 C 语言本身的效率也会提升很多。所以效率会大幅度提高。</p>
<p>下面我们来看一段代码，这段代码，只是实现了简单的素数运算，能计算指定值以内的素数个数，用的是普通的筛选法。现在看看扩展实现，跟 PHP 原生实现的效率差别，这个差别当然，不仅仅是动态类型和编译类型的差别，还有语言效率的差别。</p>
<p>首先是用纯 PHP 写成的算法，计算 1000 万以内的素数个数，耗时在 33s 上下，实验了三次，得到的结果基本相同。<br><img src="/css/images/php_10.png" alt=""><br>其次，我们将这个求素数个数的过程，编写成了 PHP 扩展，在扩展中实现了 getprimenumbers 函数，输入一个整数，返回小于该整数的素数。得到的结果如下，这个效率的提升是非常惊人的，在 1.4s 上下即返回。速度提升 20 倍以上。<br><img src="/css/images/php_11.png" alt=""><br>可以想见，静态和编译类型的语言，其效率得到了惊人的提升。本程序的 C 语言代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">PHP_FUNCTION(get_prime_numbers)</div><div class="line">&#123;</div><div class="line">    long value;</div><div class="line">    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;l&quot;, &amp;value) == FAILURE) &#123;</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">     int *numbers = (int *)malloc(sizeof(int)*128*10000);</div><div class="line">     memset(numbers, 0x0, 128*10000);</div><div class="line">    int num = 2;</div><div class="line">        numbers[0] = 2;</div><div class="line">        numbers[1] = 3;</div><div class="line">        bool flag = true;</div><div class="line">        double f = 0;</div><div class="line">        int i = 0;</div><div class="line">        int j = 0;</div><div class="line">        for(i=5; i&lt;=value; i+=2)</div><div class="line">        &#123;</div><div class="line">            flag = true;</div><div class="line">            f = sqrt(i);</div><div class="line">            for(j=0; j&lt;num;j++)</div><div class="line">            &#123;</div><div class="line">                if(i%numbers[j]==0)</div><div class="line">                &#123;</div><div class="line">                    flag = false;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if(numbers[j]&gt;f)</div><div class="line">                &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(flag)</div><div class="line">            &#123; </div><div class="line">                numbers[num] = i;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(numbers);</div><div class="line">        RETURN_LONG(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="PHP-语言本身底层性能引擎提升"><a href="#PHP-语言本身底层性能引擎提升" class="headerlink" title="PHP 语言本身底层性能引擎提升"></a>PHP 语言本身底层性能引擎提升</h3><p>第三个性能优化层面是语言本身的性能提升，这个就不是我们普通开发者所能做的了。在 PHP 7以前，寄希望于小版本的改进，但是改进幅度不是非常的显著，比如 PHP 5.3 、PHP 5.4、PHP 5.5、PHP 5.5 对同一段代码的性能比较，有一定程度的进步。</p>
<p>PHP 5.3 的版本在上面的例子中已讲过，需要 33s 左右的时间，我们现在来看别的PHP版本。分别运行如下：</p>
<p>PHP 5.4 版，相较 5.3 版已经有一定程度的提升。快 6 秒左右。<br><img src="/css/images/php_12.png" alt=""><br>PHP 5.5 版在 PHP 5.4的基础上又进了一步，快了 6S。<br><img src="/css/images/php_13.png" alt=""><br>PHP5.6 反而有些退步。<br><img src="/css/images/php_14.png" alt=""><br>PHP 7 果真是效率提升惊人，是 PHP5.3 的 3 倍以上。<br><img src="/css/images/php_15.png" alt=""><br>以上是求素数脚本在各个 PHP 版本之间的运行速度区别，尽管只测试了这一个程序，也不是特别的严谨，但是这是在同一台机器上，而且编译 configure 参数也基本一样，还是有一定可比性的。</p>
<p>在宏观层面，除了上面的这些之外，在实际的部署过程中，对 PHP 性能的优化，还体现为要减少在运行中所消耗的资源。所以 FastCGI 模式和 mod_php 的模式比传统的 CGI 模式也更为受欢迎。因为在传统的 CGI 模式中，在每一次脚本运行都需要加载所有的模块。而在程序运行完成了之后，也要释放模块资源。如下图所示：<br><img src="/css/images/php_16.png" alt=""><br>而在 FastCGI 和 mod_php 模式中，则不需要如此。只有 php-fpm 或者 Apache 启动的时候，需要加载一次所有的模块，在具体的某次运行过程中，并不需要再次加载和释放相关的模块资源。<br><img src="/css/images/php_16.png" alt=""><br>这样程序性能的效率得到了提升。以上就是有关 PHP 宏观层面的性能优化的分析，在本文的第二部分我们将探讨应用方面的 PHP 优化准则。敬请期待！</p>
]]></content>
      
        <categories>
            
            <category> php </category>
            
            <category> 底层 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
            <tag> 底层性能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网站设计中的cache技术]]></title>
      <url>/2017/03/02/cache_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/cache_1.jpg" alt=""><br>页面缓存的原理大体是在浏览器对资源的第一次请求之后，把资源中的一部分存储在计算机的临时文件空间，再次请求的时候，按照特定的策略加载缓存的资源，减少HTTP请求次数与传输数据量，以此提高浏览效率，<span style="color:blue">减少数据库和服务器的压力。</span></p>
<p>在网站设计时要充分考虑缓存，合理的利用缓存和静态技术可以大大的提高网站的运行速度。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h3><p>将动态的页面生成静态的页面保存下来，但用户访问特定的页面时，直接将缓存好的静态页面返回给客户，省去了去数据库读取数据的过程，大大提高了网站的运行效率，降低了数据库的压力。</p>
<blockquote>
<p>这里牺牲了网站数据的及时性，一般静态化缓存会和其他技术结合起来使用，而不是单独使用。</p>
</blockquote>
<p>php里一般使用ob方法来实现页面静态缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ob_start();</div><div class="line">$content = ob_get_contents();</div><div class="line">ob_end_clean();</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="页面部分静态化"><a href="#页面部分静态化" class="headerlink" title="页面部分静态化"></a>页面部分静态化</h3><p>使用模块化设计，将不需要数据动态化的部分进行静态化，使用ob函数输出，也可以使用其他技术，如ESI。</p>
<p>一般即使动态的数据，如果数据变化不是十分频繁（我们通过设计固定时间来更新我们的数据），也可以通过一些标识（如：id）来保存静态化数据的页面，然后通过（id）来找到静态页面位置，当该页面被访问时，直接返回给用户。</p>
<blockquote>
<p>这里需要设计人员分割是否需要动态数据显示</p>
</blockquote>
<hr>
<h3 id="memcached（redis）缓存"><a href="#memcached（redis）缓存" class="headerlink" title="memcached（redis）缓存"></a>memcached（redis）缓存</h3><p>内存缓存，一般使用memcached或者redis来实现，将数据以key&amp;value的方式保存在内存中，因为数据缓存在内存中，无需再去数据库里读取，这样不仅大大减轻了数据库的压力，也一样提升网站的处理速度。</p>
<blockquote>
<p>这里要注意memcached和redis的选用，如果只是单纯的key&amp;value的数据读取，那么memecached是不错的选择，如果对数据安全有要求，又需要比较复杂的数据存储形式，那么redis可能会更加适合你。具体详见<a href="#">Memcached和Redis</a></p>
</blockquote>
<hr>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p>缓存有时候是让人讨厌的东西，但对于网页设计确实不得不去考虑的东西，这里简单的列举了三个比较常见的缓存技术，当然还有许多其他的缓存技术，留待以后慢慢的整理。</p>
]]></content>
      
        <categories>
            
            <category> php </category>
            
            <category> 静态技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cache </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用phpspider开发的PHP爬虫]]></title>
      <url>/2017/01/17/phpspider_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/phpspider_1.gif" alt=""><br>开源库出处：<a href="https://github.com/owner888/phpspider" target="_blank" rel="external">Github</a></p>
<hr>
<h3 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h3><p>phpspider是一个爬虫开发框架。使用本框架，你不用了解爬虫的底层技术实现，爬虫被网站屏蔽、有些网站需要登录或验证码识别才能爬取等问题。简单几行PHP代码，就可以创建自己的爬虫，利用框架封装的多进程Worker类库，代码更简洁，执行效率更高速度更快。<br><a id="more"></a><br>demo目录下有一些特定网站的爬取规则，只要你安装了PHP环境，代码就可以在命令行下直接跑。</p>
<hr>
<h3 id="糗事百科案例"><a href="#糗事百科案例" class="headerlink" title="糗事百科案例"></a>糗事百科案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">$configs = array(</div><div class="line">   &apos;name&apos; =&gt; &apos;糗事百科&apos;,</div><div class="line">   &apos;domains&apos; =&gt; array(</div><div class="line">       &apos;qiushibaike.com&apos;,</div><div class="line">       &apos;www.qiushibaike.com&apos;</div><div class="line">   ),</div><div class="line">   &apos;scan_urls&apos; =&gt; array(</div><div class="line">       &apos;http://www.qiushibaike.com/&apos;</div><div class="line">   ),</div><div class="line">   &apos;content_url_regexes&apos; =&gt; array(</div><div class="line">       &quot;http://www.qiushibaike.com/article/\d+&quot;</div><div class="line">   ),</div><div class="line">   &apos;list_url_regexes&apos; =&gt; array(</div><div class="line">       &quot;http://www.qiushibaike.com/8hr/page/\d+\?s=\d+&quot;</div><div class="line">   ),</div><div class="line">   &apos;fields&apos; =&gt; array(</div><div class="line">       array(</div><div class="line">           // 抽取内容页的文章内容</div><div class="line">           &apos;name&apos; =&gt; &quot;article_content&quot;,</div><div class="line">           &apos;selector&apos; =&gt; &quot;//*[@id=&apos;single-next-link&apos;]&quot;,</div><div class="line">           &apos;required&apos; =&gt; true</div><div class="line">       ),</div><div class="line">       array(</div><div class="line">           // 抽取内容页的文章作者</div><div class="line">           &apos;name&apos; =&gt; &quot;article_author&quot;,</div><div class="line">           &apos;selector&apos; =&gt; &quot;//div[contains(@class,&apos;author&apos;)]//h2&quot;,</div><div class="line">           &apos;required&apos; =&gt; true</div><div class="line">       ),</div><div class="line">   ),</div><div class="line">   );</div><div class="line">   $spider = new phpspider($configs);</div><div class="line">   $spider-&gt;start();</div></pre></td></tr></table></figure>
<hr>
<h3 id="爬虫程序设计"><a href="#爬虫程序设计" class="headerlink" title="爬虫程序设计"></a>爬虫程序设计</h3><p>因为爬取的页面需要登录才能获取到关注者页面，所以从chrome登录之后把cookie拷贝下来给curl程序模拟登录。</p>
<p>使用两大独立循环进程组(用户索引进程组、用户详情进程组)，用的是php的pcntl扩展，封装了一个非常好用的类，使用起来和golang的携程也差不多了。</p>
<ol>
<li>用户索引进程组先以一个用户为起点，抓取这个用户的关注了和关注者，然后合并入库，因为是多进程，所以当有两个进程在处理同一个用户入库的时候就会出现重复的用户，所以数据库用户名字段一定要建立唯一索引，当然也可以用redis这些第三方缓存来保证原子性，这个就见仁见智了。</li>
<li><p>用户详情进程组按照时间正序，拿到最先入库的用户抓取详情，并且把更新时间更新为当前时间，这样就可以变成一个死循环，程序可以无休止的跑，不断的循环更新用户信息。</p>
</li>
<li><p>程序运行过程中出现的错误,因为网站会给数据强制gzip压缩，需要通过解压来获取有效数据</p>
<blockquote>
<p>$content = substr($content, 10);<br>$content = gzinflate($content));<br>curl_setopt( self::$ch, CURLOPT_ENCODING, ‘gzip’ );</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="获取数据的作用（感想）"><a href="#获取数据的作用（感想）" class="headerlink" title="获取数据的作用（感想）"></a>获取数据的作用（感想）</h3><p>将一堆数据进行分类分析，通过数据的分布可以分析出平常不易看出来的规律，对于我们的决策有很大的指引意义。</p>
<p>原文出处：<a href="http://www.epooll.com/archives/806/" target="_blank" rel="external">event poll</a></p>
]]></content>
      
        <categories>
            
            <category> 数据技术 </category>
            
            <category> 爬虫 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 拿来的东西 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis vs memecached]]></title>
      <url>/2016/12/03/redis_vs_mem/</url>
      <content type="html"><![CDATA[<p>Redis 是由来自意大利西西里岛的Salvatore Sanfilippo开发的一款开源的，使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。</p>
<p>这里不得不说一个勤奋的作者对一款开源软件是一件很重要的事，时至今日，与前辈memcached相比，Redis在大多数方面已经完成了全面的超越。</p>
<p>下面摘录一段在stackoverflow上看到关于redis的文章。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>Redis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap.<br>For anything new, use Redis.</p>
<blockquote>
<p>Redis拥有着更加强大和丰富的功能</p>
</blockquote>
<h3 id="Memcached-vs-Redis-Direct-Comparison"><a href="#Memcached-vs-Redis-Direct-Comparison" class="headerlink" title="Memcached vs Redis: Direct Comparison"></a>Memcached vs Redis: Direct Comparison</h3><p>Both tools are powerful, fast, in-memory data stores that are useful as a cache. Both can help speed up your application by caching database results, HTML fragments, or anything else that might be expensive to generate.</p>
<blockquote>
<p>两者都是通过使用内存缓存，来帮助你的网站提速</p>
</blockquote>
<h3 id="Points-to-Consider"><a href="#Points-to-Consider" class="headerlink" title="Points to Consider"></a>Points to Consider</h3><pre><code>1. Read/write speed: Both are extremely fast. Benchmarks vary by workload, versions, and many other factors but generally show redis to be as fast or almost as fast as memcached. I recommend redis, but not because memcached is slow. It&apos;s not.
2. Memory usage: Redis is better.
    memcached: You specify the cache size and as you insert items the daemon quickly grows to a little more than this size. There is never really a way to reclaim any of that space, short of restarting memcached. All your keys could be expired, you could flush the database, and it would still use the full chunk of RAM you configured it with.
    redis: Setting a max size is up to you. Redis will never use more than it has to and will give you back memory it is no longer using.
    I stored 100,000 ~2KB strings (~200MB) of random sentences into both. Memcached RAM usage grew to ~225MB. Redis RAM usage grew to ~228MB. After flushing both, redis dropped to ~29MB and memcached stayed at ~225MB. They are similarly efficient in how they store data, but only one is capable of reclaiming it.
3. Disk I/O dumping: A clear win for redis since it does this by default and has very configurable persistence. Memcached has no mechanisms for dumping to disk without 3rd party tools.
4. Scaling: Both give you tons of headroom before you need more than a single instance as a cache. Redis includes tools to help you go beyond that while memcached does not.
</code></pre><blockquote>
<p>我们需要从以下4点来分析使用redis的优势</p>
<ol>
<li>读写速度</li>
<li>内存使用</li>
<li>磁盘I/O dumping</li>
<li>缩放</li>
</ol>
</blockquote>
<h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><p>Memcached is a simple volatile cache server. It allows you to store key/value pairs where the value is limited to being a string up to 1MB.</p>
<p>It’s good at this, but that’s all it does. You can access those values by their key at extremely high speed, often saturating available network or even memory bandwidth.</p>
<p>When you restart memcached your data is gone. This is fine for a cache. You shouldn’t store anything important there.</p>
<p>If you need high performance or high availability there are 3rd party tools, products, and services available.</p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>Redis can do the same jobs as memcached can, and can do them better.</p>
<p>Redis can act as a cache as well. It can store key/value pairs too. In redis they can even be up to 512MB.</p>
<p>You can turn off persistence and it will happily lose your data on restart too. If you want your cache to survive restarts it lets you do that as well. In fact, that’s the default.</p>
<p>It’s super fast too, often limited by network or memory bandwidth.</p>
<p>If one instance of redis/memcached isn’t enough performance for your workload, redis is the clear choice. Redis includes cluster support and comes with high availability tools (redis-sentinel) right “in the box”. Over the past few years redis has also emerged as the clear leader in 3rd party tooling. Companies like Redis Labs, Amazon, and others offer many useful redis tools and services. The ecosystem around redis is much larger. The number of large scale deployments is now likely greater than for memcached.</p>
<blockquote>
<p>从支持数据大小，速度，以及第三方支持来看两者的区别</p>
</blockquote>
<h3 id="The-Redis-Superset"><a href="#The-Redis-Superset" class="headerlink" title="The Redis Superset"></a>The Redis Superset</h3><p>Redis is more than a cache. It is an in-memory data structure server. Below you will find a quick overview of things Redis can do beyond being a simple key/value cache like memcached. Most of redis’ features are things memcached cannot do.</p>
<blockquote>
<p>Redis不仅仅作为一个cache来使用，他还是一个能够永久保存数据的NoSQL数据库</p>
</blockquote>
<h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>Redis is better documented than memcached. While this can be subjective, it seems to be more and more true all the time.</p>
<p>redis.io is a fantastic easily navigated resource. It lets you try redis in the browser and even gives you live interactive examples with each command in the docs.</p>
<p>There are now 2x as many stackoverflow results for redis as memcached. 2x as many Google results. More readily accessible examples in more languages. More active development. More active client development. These measurements might not mean much individually, but in combination they paint a clear picture that support and documentation for redis is greater and much more up-to-date.</p>
<blockquote>
<p>Redis有着更丰富的文档支持</p>
</blockquote>
<h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><p>By default redis persists your data to disk using a mechanism called snapshotting. If you have enough RAM available it’s able to write all of your data to disk with almost no performance degradation. It’s almost free!</p>
<p>In snapshot mode there is a chance that a sudden crash could result in a small amount of lost data. If you absolutely need to make sure no data is ever lost, don’t worry, redis has your back there too with AOF (Append Only File) mode. In this persistence mode data can be synced to disk as it is written. This can reduce maximum write throughput to however fast your disk can write, but should still be quite fast.</p>
<p>There are many configuration options to fine tune persistence if you need, but the defaults are very sensible. These options make it easy to setup redis as a safe, redundant place to store data. It is a real database.</p>
<h3 id="Many-Data-Types"><a href="#Many-Data-Types" class="headerlink" title="Many Data Types"></a>Many Data Types</h3><p>Memcached is limited to strings, but Redis is a data structure server that can serve up many different data types. It also provides the commands you need to make the most of those data types.</p>
<h4 id="Strings-commands"><a href="#Strings-commands" class="headerlink" title="Strings (commands)"></a>Strings (commands)</h4><p>Simple text or binary values that can be up to 512MB in size. This is the only data type redis and memcached share, though memcached strings are limited to 1MB.</p>
<p>Redis gives you more tools for leveraging this datatype by offering commands for bitwise operations, bit-level manipulation, floating point increment/decrement support, range queries, and multi-key operations. Memcached doesn’t support any of that.</p>
<p>Strings are useful for all sorts of use cases, which is why memcached is fairly useful with this data type alone.</p>
<h4 id="Hashes-commands"><a href="#Hashes-commands" class="headerlink" title="Hashes (commands)"></a>Hashes (commands)</h4><p>Hashes are sort of like a key value store within a key value store. They map between string fields and string values. Field-&gt;value maps using a hash are slightly more space efficient than key-&gt;value maps using regular strings.</p>
<p>Hashes are useful as a namespace, or when you want to logically group many keys. With a hash you can grab all the members efficiently, expire all the members together, delete all the members together, etc. Great for any use case where you have several key/value pairs that need to grouped.</p>
<p>One example use of a hash is for storing user profiles between applications. A redis hash stored with the user ID as the key will allow you to store as many bits of data about a user as needed while keeping them stored under a single key. The advantage of using a hash instead of serializing the profile into a string is that you can have different applications read/write different fields within the user profile without having to worry about one app overriding changes made by others (which can happen if you serialize stale data).</p>
<h4 id="Lists-commands"><a href="#Lists-commands" class="headerlink" title="Lists (commands)"></a>Lists (commands)</h4><p>Redis lists are ordered collections of strings. They are optimized for inserting, reading, or removing values from the top or bottom (aka: left or right) of the list.</p>
<p>Redis provides many commands for leveraging lists, including commands to push/pop items, push/pop between lists, truncate lists, perform range queries, etc.</p>
<p>Lists make great durable, atomic, queues. These work great for job queues, logs, buffers, and many other use cases.</p>
<h4 id="Sets-commands"><a href="#Sets-commands" class="headerlink" title="Sets (commands)"></a>Sets (commands)</h4><p>Sets are unordered collections of unique values. They are optimized to let you quickly check if a value is in the set, quickly add/remove values, and to measure overlap with other sets.</p>
<p>These are great for things like access control lists, unique visitor trackers, and many other things. Most programming languages have something similar (usually called a Set). This is like that, only distributed.</p>
<p>Redis provides several commands to manage sets. Obvious ones like adding, removing, and checking the set are present. So are less obvious commands like popping/reading a random item and commands for performing unions and intersections with other sets.</p>
<h4 id="Sorted-Sets-commands"><a href="#Sorted-Sets-commands" class="headerlink" title="Sorted Sets (commands)"></a>Sorted Sets (commands)</h4><p>Sorted Sets are also collections of unique values. These ones, as the name implies, are ordered. They are ordered by a score, then lexicographically.</p>
<p>This data type is optimized for quick lookups by score. Getting the highest, lowest, or any range of values in between is extremely fast.</p>
<p>If you add users to a sorted set along with their high score, you have yourself a perfect leader-board. As new high scores come in, just add them to the set again with their high score and it will re-order your leader-board. Also great for keeping track of the last time users visited and who is active in your application.</p>
<p>Storing values with the same score causes them to be ordered lexicographically (think alphabetically). This can be useful for things like auto-complete features.</p>
<p>Many of the sorted set commands are similar to commands for sets, sometimes with an additional score parameter. Also included are commands for managing scores and querying by score.</p>
<blockquote>
<p>Redis丰富的数据类型支持</p>
<h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3></blockquote>
<p>Redis has several commands for storing, retrieving, and measuring geographic data. This includes radius queries and measuring distances between points.</p>
<p>Technically geographic data in redis is stored within sorted sets, so this isn’t a truly separate data type. It is more of an extension on top of sorted sets.</p>
<h3 id="Bitmap-and-HyperLogLog"><a href="#Bitmap-and-HyperLogLog" class="headerlink" title="Bitmap and HyperLogLog"></a>Bitmap and HyperLogLog</h3><p>Like geo, these aren’t completely separate data types. These are commands that allow you to treat string data as if it’s either a bitmap or a hyperloglog.</p>
<p>Bitmaps are what the bit-level operators I referenced under Strings are for. This data type was the basic building block for reddit’s recent collaborative art project: r/Place.</p>
<p>HyperLogLog allows you to use a constant extremely small amount of space to count almost unlimited unique values with shocking accuracy. Using only ~16KB you could efficiently count the number of unique visitors to your site, even if that number is in the millions.</p>
<h3 id="Transactions-and-Atomicity"><a href="#Transactions-and-Atomicity" class="headerlink" title="Transactions and Atomicity"></a>Transactions and Atomicity</h3><p>Commands in redis are atomic, meaning you can be sure that as soon as you write a value to redis that value is visible to all clients connected to redis. There is no wait for that value to propagate. Technically memcached is atomic as well, but with redis adding all this functionality beyond memcached it is worth noting and somewhat impressive that all these additional data types and features are also atomic.</p>
<p>While not quite the same as transactions in relational databases, redis also has transactions that use “optimistic locking” (WATCH/MULTI/EXEC).</p>
<h3 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h3><p>Redis provides a feature called ‘pipelining’. If you have many redis commands you want to execute you can use pipelining to send them to redis all-at-once instead of one-at-a-time.</p>
<p>Normally when you execute a command to either redis or memcached, each command is a separate request/response cycle. With pipelining, redis can buffer several commands and execute them all at once, responding with all of the responses to all of your commands in a single reply.</p>
<p>This can allow you to achieve even greater throughput on bulk importing or other actions that involve lots of commands.</p>
<h3 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h3><p>Redis has commands dedicated to pub/sub functionality, allowing redis to act as a high speed message broadcaster. This allows a single client to publish messages to many other clients connected to a channel.</p>
<p>Redis does pub/sub as well as almost any tool. Dedicated message brokers like RabbitMQ may have advantages in certain areas, but the fact that the same server can also give you persistent durable queues and other data structures your pub/sub workloads likely need, Redis will often prove to be the best and most simple tool for the job.</p>
<h3 id="Lua-Scripting"><a href="#Lua-Scripting" class="headerlink" title="Lua Scripting"></a>Lua Scripting</h3><p>You can kind of think of lua scripts like redis’s own SQL or stored procedures. It’s both more and less than that, but the analogy mostly works.</p>
<p>Maybe you have complex calculations you want redis to perform. Maybe you can’t afford to have your transactions roll back and need guarantees every step of a complex process will happen atomically. These problems and many more can be solved with lua scripting.</p>
<p>The entire script is executed atomically, so if you can fit your logic into a lua script you can often avoid messing with optimistic locking transactions.</p>
<h3 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h3><p>As mentioned above, redis includes built in support for clustering and is bundled with its own high availability tool called redis-sentinel.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Without hesitation I would recommend redis over memcached for any new projects, or existing projects that don’t already use memcached.</p>
<p>The above may sound like I don’t like memcached. On the contrary: it is a powerful, simple, stable, mature, and hardened tool. There are even some use cases where it’s a little faster than redis. I love memcached. I just don’t think it makes much sense for future development.</p>
<p>Redis does everything memcached does, often better. Any performance advantage for memcached is minor and workload specific. There are also workloads for which redis will be faster, and many more workloads that redis can do which memcached simply can’t. The tiny performance differences seem minor in the face of the giant gulf in functionality and the fact that both tools are so fast and efficient they may very well be the last piece of your infrastructure you’ll ever have to worry about scaling.</p>
<p>There is only one scenario where memcached makes more sense: where memcached is already in use as a cache. If you are already caching with memcached then keep using it, if it meets your needs. It is likely not worth the effort to move to redis and if you are going to use redis just for caching it may not offer enough benefit to be worth your time. If memcached isn’t meeting your needs, then you should probably move to redis. This is true whether you need to scale beyond memcached or you need additional functionality.</p>
<h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><p>翻译无能啊，英文水平略显不足，还有就是专业纵深也不够，一些名词直接看不懂是什么意思，文章看到后半段的时候，脑子一片空白，虽然看得懂小半的意思，但是却不能理解具体的区别作用。</p>
<p>还有文章作者最后的一句话，I love memcached. I just don’t think it makes much sense for future development.莫名的让人有些难言的干涩，也摘下来共勉吧。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> nosql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> nosql </tag>
            
            <tag> memcached </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式服务器集群架构方案思考]]></title>
      <url>/2016/07/15/zfenbu_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/z_fenbu_1.jpg" alt=""><br>网上看到一个分布式的服务器集群架构，看了下觉得自己对于分布式的理解清晰了不少，于是摘录下来以免丢失。<br><a id="more"></a><br>原文出处：<a href="http://homeway.me/2014/12/10/think-about-distributed-clusters/" target="_blank" rel="external">分布式服务器集群架构方案思考 by 夏日小草</a></p>
<hr>
<h3 id="大型网站演化"><a href="#大型网站演化" class="headerlink" title="大型网站演化"></a>大型网站演化</h3><p>简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。</p>
<p>集群主要分为：高可用集群(High Availability Cluster)，负载均衡集群(Load Balance Cluster，nginx即可实现)，科学计算集群(High Performance Computing Cluster)。</p>
<p>分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。</p>
<p>之前在网上看到一篇关于大型网站演化的博客。<a href="http://www.cnblogs.com/leefreeman/p/3993449.html" target="_blank" rel="external">page</a></p>
<p>每个大型网站都会有不同的架构模式，而架构内容也就是在处理均衡负载，缓存，数据库，文件系统等，只是在不同的环境下，不同的条件下，架构的模型不一样，目的旨在提高网站的性能。</p>
<p>最初的架构只有应用程序，数据库，文件服务。<br><img src="/css/images/z_fenbu_1_1.jpg" alt="应用程序、数据库、文件服务架构"><br>到后来，分布式服务、集群架设。<br><img src="/css/images/z_fenbu_1_2.jpg" alt="分布式服务器集群"></p>
<hr>
<h3 id="关于均衡负载方案"><a href="#关于均衡负载方案" class="headerlink" title="关于均衡负载方案"></a>关于均衡负载方案</h3><p>在上一篇，<a href="http://homeway.me/2014/12/05/nginx-reverse-proxy-to-load-balance/" target="_blank" rel="external">《Nginx反向代理实现均衡负载》</a>讨论过过的nginx现实均衡负载方案，这里选择另一种HAProxy+Keepalived双机高可用均衡负载方案。</p>
<p>HAProxy是免费、极速且可靠的用于为TCP和基于HTTP应用程序提供高可用、负载均衡和代理服务的解决方案，尤其适用于高负载且需要持久连接或7层处理机制的web站点。</p>
<p>不论是Haproxy还是Keepalived甚至是上游服务器均提高生产力并增强可用性,也就是如下架构中Haproxy,Keepalived,Httpd服务器任意宕机一台服务还是可以正常运行的。</p>
<p>HAProxy的优点：</p>
<p>1、HAProxy是支持虚拟主机的，可以工作在4、7层(支持多网段)；</p>
<p>2、能够补充Nginx的一些缺点比如Session的保持，Cookie的引导等工作；</p>
<p>3、支持url检测后端的服务器；</p>
<p>4、本身仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的；</p>
<p>5、HAProxy可以对Mysql读进行负载均衡，对后端的MySQL节点进行检测和负载均衡；<br><img src="/css/images/z_fenbu_1_3.jpg" alt="HAProxy+Keepalive 均衡负载方案"></p>
<hr>
<h3 id="关于Redis缓存方案"><a href="#关于Redis缓存方案" class="headerlink" title="关于Redis缓存方案"></a>关于Redis缓存方案</h3><p>缓存分为服务器缓存和应用程序缓存。</p>
<p>关于应用程序内缓存，已经在<a href="https://github.com/grasses/Jue-MVC" target="_blank" rel="external">Jue后台框架</a>里面做了模块处理了。</p>
<p>关于服务器缓存，主要缓存服务器文件，减少服务器和php交互，减少均衡负载服务器和应用程序服务器交互。</p>
<p>缓存里面有一种典型的memcached，现在用的多的是redis轻量级缓存方案。</p>
<p>关于memcached与redis，看这篇 <a href="http://www.bigdatalittlegeek.com/blog/2014/3/25/memcached-vs-redis" target="_blank" rel="external">《Memcached vs Redis?》</a></p>
<p>Redis主要将数据存储在各种格式：列表，数组，集合和排序集，一次能接受多个命令，阻塞读写，等待直到另一个进程将数据写入高速缓存。<br><img src="/css/images/z_fenbu_1_4.jpg" alt="Redis Cache 方案"><br>一篇关于Reids缓存方案。<a href="http://www.infoq.com/cn/news/2014/11/open-source-redis-cache" target="_blank" rel="external">《高可用、开源的Redis缓存集群方案》</a></p>
<hr>
<h3 id="关于NoSQL快速存储方案"><a href="#关于NoSQL快速存储方案" class="headerlink" title="关于NoSQL快速存储方案"></a>关于NoSQL快速存储方案</h3><p>NoSQL在这里的使用价值是处理一些琐事，比如用户个人网站的一些css值，height,width,color等等的小而繁多的数据，采用NoSQL旨在提升数据库速度，减少对MySQL的SELECT请求。</p>
<p>关于NoSQL的方案很多了，选一个简单的MongDB好了。</p>
<hr>
<h3 id="关于分布式MySQL方案"><a href="#关于分布式MySQL方案" class="headerlink" title="关于分布式MySQL方案"></a>关于分布式MySQL方案</h3><p>(做分布式MySQL还没尝试过，初期也不清楚mysql所需要的压力，所以第一期不打算做分布式MySQL)</p>
<p><a href="http://www.infoq.com/cn/news/2014/11/mysql-five-open-source-project" target="_blank" rel="external">《标准MySQL数据库外的5个开源兼容方案》</a></p>
<hr>
<h3 id="分布式集群方案"><a href="#分布式集群方案" class="headerlink" title="分布式集群方案"></a>分布式集群方案</h3><p>综合起来，大致就是如下模型，初探分布式架构，还有很多要修改的，待续，时时更新中…<br><img src="/css/images/z_fenbu_1_5.png" alt="Redis Cache 方案"></p>
<hr>
<h3 id="观后所感"><a href="#观后所感" class="headerlink" title="观后所感"></a>观后所感</h3><p>一个完整的架构设计并不是一件简单的事，其中涉及的知识很多，我也心知一口气吃不成胖子，更多的问题留待自己有更加成熟的思考和理解之后，再来整理</p>
]]></content>
      
        <categories>
            
            <category> 分布式部署 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 拿来的东西 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四种基本的排序算法学习总结]]></title>
      <url>/2016/06/23/algorithm_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/algorithm_1.jpg" alt=""><br>都说算法是程序的核心,但是作为一个半路出家的程序员，情不自禁的有点畏惧这个东西，但是今天却被教训了一顿，因为亲眼目睹前辈以一个简单的排序方法提升了好几倍的查询速度，好吧，决心一点点的啃下算法的硬骨头，提升一点自己coding的视野和高度。<br><a id="more"></a></p>
<h2 id="今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。"><a href="#今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。" class="headerlink" title="今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。"></a>今天就整理一下最简单的四个排序算法：冒泡、快速、选择、插入。</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>对一个乱序的数组，每次选择一个指定位置的元素（一般是第一个），每次scan，将被选择的元素作为基准，将乱序的数组分为大小两部分，后续递归剩下的部分，直到分割出来的数组长度不可再分。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function quick_sort($arr) &#123; </div><div class="line">	$length = count($arr); </div><div class="line">	if($length &lt;= 1) &#123; //递归出口</div><div class="line">		return $arr; </div><div class="line">	&#125; </div><div class="line">	$base_array = $arr[0]; //选择第一个元素作为基准 </div><div class="line">	//初始化两个数组,保证每次递归签数组清空</div><div class="line">	$left_array = array();  //小于基准的 </div><div class="line">	$right_array = array();  //大于基准的 </div><div class="line">	for($i=1; $i&lt;$length; $i++) &#123; </div><div class="line">		if($base_num &gt; $arr[$i]) &#123;//放入左边数组  </div><div class="line">			$left_array[] = $arr[$i]; </div><div class="line">		&#125; else &#123; //放入右边 </div><div class="line">			$right_array[] = $arr[$i]; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	//递归排序</div><div class="line">	$left_array = quick_sort($left_array); </div><div class="line">	$right_array = quick_sort($right_array); </div><div class="line">	//合并数组 </div><div class="line">	return array_merge($left_array, array($base_num), $right_array); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序基本是一个programer要学习的第一个算法，但是简单不代表他真的就low，就像递归和迭代算法一样，并没有那个算法是最优的，而是适当的环境下选择适当的算法。冒泡算法，通过两层循环，从第一个元素开始，每次对比相邻的元素，依据他们的大小和需要的排序决定他们的位置，最后获得一个重新排序过的数组。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function bubbleSort($arr)&#123; </div><div class="line">  $len=count($arr); </div><div class="line">  for($i=1;$i&lt;$len;$i++) &#123; //第一层循环控制层数  </div><div class="line">    for($k=0;$k&lt;$len-$i;$k++)&#123; //第二层循环用来控制级数</div><div class="line">       if($arr[$k]&gt;$arr[$k+1])&#123;</div><div class="line">            $tmp=$arr[$k+1]; </div><div class="line">            $arr[$k+1]=$arr[$k]; </div><div class="line">            $arr[$k]=$tmp; </div><div class="line">       &#125; </div><div class="line">    &#125; </div><div class="line">  &#125; </div><div class="line">  return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是通过假设一个假值，然后获得这个假值的位置（每次选择最大或者最小的树），寻找到他的位置，排列出一个固定顺序的数组。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function selectSort($arr) &#123; </div><div class="line">	//双重循环完成，外层控制轮数，内层控制比较次数 </div><div class="line">	$len=count($arr); </div><div class="line">	for($i=0; $i&lt;$len-1; $i++) &#123; </div><div class="line">		//假设最小的值的位置 </div><div class="line">		$p = $i; </div><div class="line">		for($j=$i+1; $j&lt;$len; $j++) &#123; </div><div class="line">			//比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。</div><div class="line">			if($arr[$p] &gt; $arr[$j]) &#123;  </div><div class="line">			$p = $j; </div><div class="line">			&#125; </div><div class="line">		&#125; </div><div class="line">		//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。 </div><div class="line">		if($p != $i) &#123; </div><div class="line">			$tmp = $arr[$p]; </div><div class="line">			$arr[$p] = $arr[$i]; </div><div class="line">			$arr[$i] = $tmp; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	//返回最终结果 </div><div class="line">	return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>假设一个数组是有序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br>具体举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function insertSort($arr) &#123; </div><div class="line">	$len=count($arr); </div><div class="line">	for($i=1, $i&lt;$len; $i++) &#123; </div><div class="line">		$tmp = $arr[$i]; </div><div class="line">		//内层循环控制，比较并插入 </div><div class="line">		for($j=$i-1;$j&gt;=0;$j--) &#123; </div><div class="line">			if($tmp &lt; $arr[$j]) &#123; </div><div class="line">				//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 </div><div class="line">				$arr[$j+1] = $arr[$j]; </div><div class="line">				$arr[$j] = $tmp; </div><div class="line">			&#125; else &#123; </div><div class="line">				//如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。 </div><div class="line">				break; </div><div class="line">			&#125; </div><div class="line">		&#125; </div><div class="line">	&#125; </div><div class="line">	return $arr; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git操作(I) 提交到远程仓库]]></title>
      <url>/2016/05/27/git_1/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/git_1.jpg" alt=""><br>目前市面有许多第三方git操作软件，比如我曾经用过的<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a>，就是一款上手和使用起来都不错的工具，但时间一长，总觉得差点微妙的feel，于是又灰溜溜的决定把命令行捡回来，写个系列的使用记录。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="创建一个本地仓库"><a href="#创建一个本地仓库" class="headerlink" title="创建一个本地仓库"></a>创建一个本地仓库</h3><ol>
<li>现在，有一个尚未开始的项目，那么进入你项目存放的目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd XXX</div><div class="line">$ git init</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样你就获得了一个仓库，并且处于当前<span style="color:green">master branch</span>上</p>
<ol>
<li>或者通过clone一个远程的仓库到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd XXX</div><div class="line">$ git clone url:repositories [repo&apos;s name]</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>需要注意的是，这个本地文件夹（<span style="color:red">XXX</span>）要是一个空的文件夹，否则会报错</p>
</blockquote>
<hr>
<h3 id="完成文件提交"><a href="#完成文件提交" class="headerlink" title="完成文件提交"></a>完成文件提交</h3><ol>
<li>创建一个本地文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim ./hello_git.md</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在文件输入你想加入的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ hello git :)</div></pre></td></tr></table></figure></p>
<p>保存后退出</p>
<ol>
<li>添加文件到暂存区，提交文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">使用</div><div class="line">$ git status</div><div class="line">查看当前文件状态，出现未添加文件，使用</div><div class="line">$ git add ./hello_git.md</div><div class="line">再查看文件状态‘</div><div class="line">$ git status</div><div class="line">这里显示文件暂存，然后准备commit</div><div class="line">$ git commit -m &apos;备注信息&apos;</div><div class="line">再次查看工作区时，显示tree clean，说明提交成功</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>你也可以使用 git status -s 命令查看更为详细的状态<br>也可以通过 git log 来查看每次commit</p>
</blockquote>
<hr>
<h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>git 属于分布式版本控制系统,每个电脑就相当于一个仓库，但如果你有一个geek的心，你可以将你的代码分享到一个远程的托管系统上，其中的代表有世界上最大的同性交友网站<a href="https://github.com/" target="_blank" rel="external">github</a>，还有国内的两个不错的托管平台<a href="https://coding.net/" target="_blank" rel="external">coding</a>和<a href="https://git.oschina.net/" target="_blank" rel="external">码云</a>。</p>
<p>我们可以通过remote命令将自己的代码托管在远程的代码托管平台上</p>
<ol>
<li>查看关联的远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
</li>
</ol>
<p>获得已经关联的远程仓库<br>2 . 配置本地账户信息<br>配置一个本地的用户信息，使得仓库中的操作是由谁做出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your_username&quot;  </div><div class="line">$ git config --global user.email your_email@domain.com</div></pre></td></tr></table></figure></p>
<ol>
<li>生成ssh秘钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your_email@domain.com&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输入命令之后会提示三次确认，一直回车确定，最后提示创建成功，然后进入主文件查看生成的id_rsa和id_rsa.pub，将id_rsa.pub公钥打开，添加到远程创建的长裤中</p>
<blockquote>
<p>打开公钥使用编辑器，否则可能会影响编码，导致添加失败</p>
</blockquote>
<ol>
<li>添加远程仓库地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin https://your_username@bitbucket.org/your_username/name_of_remote_repository.git </div><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显示push成功之后，就可以再远程仓库里看到你提交的代码了</p>
<blockquote>
<p>如果使用的clone仓库，那么本地默认存在远程仓库地址，只需要添加ssh公钥认证之后就可以提交代码到远程仓库了</p>
</blockquote>
<hr>
<p>如果你看了这些还是不太了解提交的过程，可以参考git官方给出的<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">操作book</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[好玩的ReidsCycle]]></title>
      <url>/2016/05/16/rediscycle/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/yanshi_1.bmp" alt=""><br>最近，突发奇想的想要设计一个延时触发的项目，上网翻腾了一把，着实发现了不少有意思的东西，这里附上感觉不错的两处：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959961&idx=1&sn=afec02c8dc6db9445ce40821b5336736&scene=0#wechat_redirect" target="_blank" rel="external">一</a>、<a href="https://github.com/chaiyue/delayed" target="_blank" rel="external">二</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="比较常见的方案"><a href="#比较常见的方案" class="headerlink" title="比较常见的方案"></a>比较常见的方案</h3><p>使用cron定时任务，但是cron设定任务最低的<span style="color:red">精度</span>到<span style="color:blue">minute</span>,某些时候，我们需要的可能是精确到<span style="color:blue">second</span>级别的定时计划。</p>
<p>再者，当表单数据量巨大时，使用cron进行轮询的效率就很低。</p>
<blockquote>
<p>因为，每次轮询都要扫一次库，之前执行过的记录仍会被扫描，这样的效率就会下降</p>
</blockquote>
<hr>
<h3 id="使用redis实现高效的延时设计"><a href="#使用redis实现高效的延时设计" class="headerlink" title="使用redis实现高效的延时设计"></a>使用redis实现高效的延时设计</h3><p>参见<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959961&idx=1&sn=afec02c8dc6db9445ce40821b5336736&scene=0#wechat_redirect" target="_blank" rel="external">一</a>中的设计，这里包含两个重要的数据结构：</p>
<blockquote>
<ol>
<li><span style="color:red">环形队列</span>，一个头尾相接数组，其包含3600个slot的环形队列（一环设计为1h==60min==3600s，cycle=n?）</li>
<li><span style="color:red">work_ task</span>, 置于指定时间点的 [‘set’=&gt;[cycle,dot,work_task]]</li>
<li><span style="color:red">timer</span>, 一个和环形队列对应的timer是必须的,每当timer变化设定的dot值时，环形队列的指针（index）便移动一位，同事检测当前dot上的set集，对比集中cycle，如果对应上，便执行此点上的work_ task</li>
</ol>
</blockquote>
<p>这里我们设定一个例子：</p>
<ol>
<li>slot(3600,dot=1s)</li>
<li>timer=dot=1s</li>
<li>set=[task_1=&gt;[‘cycle’=&gt;3,’dot’=&gt;667,’task’=&gt;function(){echo ‘do it’}]]</li>
</ol>
<p>任务执行的逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(cycle=1,dot=667)--&gt;1 != 3 &amp;&amp; 667 == 667 continue</div><div class="line">(cycle=2,dot=667)--&gt;2 != 3 &amp;&amp; 667 == 667 continue</div><div class="line">(cycle=3,dot=667)--&gt;3 == 3 &amp;&amp; 667 == 667 do work_task--&gt;echo do it--&gt;delete work_task</div></pre></td></tr></table></figure></p>
<p>从任务的逻辑不难看出，</p>
<ol>
<li>每次指针移动时，只需要查看当前dot上是否有set如果有set集则进行判断cycle值，决定是否执行任务，无需轮询全部任务，效率提升</li>
<li>每个订单任务被执行之后，即刻更新任务数据，一个任务只执行一次</li>
<li>时效性自定义，再不影响系统性能的情况下，就能够做到足够高的精确度</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> nosql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 环形队列 </tag>
            
            <tag> 延时设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP+salt加密]]></title>
      <url>/2016/05/13/php+salt/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mima_1.bmp" alt=""><br><a id="more"></a><br>最近又听闻用户信息泄露的新闻，此前，作为it小白的时候，实在不知道怎么处理这样的变故，而泄漏的信息如果被黑客利用，通过撞库的方法就可破解大多数用户的密码，毕竟用户偏向于使用自己简单容易记住的密码，也不会多去改变他们，这时，如果我们开发人员还使用单一的加密方式，那是十分不明智的。</p>
<hr>
<h3 id="MD5加盐加密"><a href="#MD5加盐加密" class="headerlink" title="MD5加盐加密"></a>MD5加盐加密</h3><p>我们对md5()这个函数再是熟悉不过了，都使用过md5()对用户密码进行加密处理，这样做没有错，因为MD5加密不可逆，但是这样做的安全性还是很低的，因为很多网站的用户数据都是用md5进行加密处理的，而且网上也有许多人为整理出来的常用的MD5加密库，而从CSDN当时泄漏出来的用户信息来看，即便是作为与网络打交道的程序员，其中也有许多使用的是简单的密码组合，及其容易被匹配出来，再者，对于黑客而言，其破解密码手段通过撞库，简单的密码组合就大大增大了密码被破解的几率。</p>
<p>直接去开发一个新的算法来加密，从现实的角度是不实际的，那既然从算法的角度无法实现，那么我们就可以从入口的数据下手，将用户的密码添加一些佐料，这样即便是简单的密码，也会因为我们的加密，提升了密码组合的复杂程度，不会那么轻易的被破解，这就是所谓的加salt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$salt = get_salt(SALT); //我们通过设置不同的SALT值来获取不同等级的加密</div><div class="line">$password = &apos;we2134sda&apos;; //用户处获取的明文密码</div><div class="line">$md5_password = md5(&apos;your_site&apos;.$password.$salt);//最终加密后密码</div><div class="line">function get_salt（$param） &#123;</div><div class="line">	$salt = &apos;&apos;;</div><div class="line">	for ($i = 0;$i &lt; $param; $i++) &#123;</div><div class="line">		$salt .= chr(mt_rand(13,$param*12+13));</div><div class="line">	&#125;</div><div class="line">	return $salt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们使用md5加随机生成的salt来增强加密后的密码安全性，然后我们记录下salt值，在用户注册的时候和密码一起生成并保存到数据库中，用户登录验证的时候再把密码和盐值一起组合验证，通过这样的手段就可以加强密码的安全性。</p>
]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> md5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用hexo+github搭建一个静态blog]]></title>
      <url>/2016/05/03/your%20blog/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/blog_1.jpg" alt=""><br>关于怎么搭建blog的教程网上有一堆，挑一个比较详细的附上：<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>这里就记录一些个人探过的一些小坑，以做前车之鉴。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>使用hexo搭建blog的时候系统默认了一个theme：landscape</p>
<p>我使用的是这个主题：<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external">ICARUS</a></p>
<p>下载之后要在主配置文件 _config.yaml里配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: hexo-theme-icarus //你所下载的主题仓库名称</div></pre></td></tr></table></figure></p>
<p>而如果需要调整请在主题文件夹的 _config.yaml里配置</p>
<blockquote>
<p>注意两者的位置<br>主配置文件位于hexo文件的根目录中<br>主题配置文件的目录位于hexo-&gt;themes-&gt;(your themes)-&gt;_config.yaml(一般出事文件还有后缀example，将他去掉就好了)</p>
</blockquote>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>使用<span style="color:green;font-size:20px">$ hexo d</span> 就可以将生成好的静态文件部署到github上，但部署文件之前需要在主配置文件里配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line"> 		type: git</div><div class="line"> 		repo: https://github.com/yourgithubname/yourgithubname.github.io.git</div><div class="line"> 		branch: master</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，这里的仓库名称一定要是你的：github用户名.github.io才会被github默认为pages</p>
</blockquote>
<p>但需要注意的是，有些时候这样的配置不一定能够成功，因为在hexo3里使用<span style="color:red">https://</span> 会影响他的部署<br>这里要将仓库地址repo改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo：git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>
<p>如果还是失败，那就要检查SSH key是否添加成功，以及git的设置是否成功</p>
<h3 id="关于MarkDown的书写"><a href="#关于MarkDown的书写" class="headerlink" title="关于MarkDown的书写"></a>关于MarkDown的书写</h3><p>使用hexo new post [post title],可以生成一篇新的文章，只需要到<span style="color:purple">/source/_post/</span>下就可以找到生成的title.md文件<br>下面是标题文件的书写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: blog标题</div><div class="line">categories: [一级分类，二级分类...]</div><div class="line">tags: [标签1,标签2,标签3...]</div><div class="line">thumbnail: url of image(缩略图的路径)</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>博文正文的书写惨遭markdown语法，markdown语法兼容html的语法，相信对学习过html标签都不是一件难事。<br>这里再提一点，如果需要只显示部分的博文可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!--more--&gt;</div></pre></td></tr></table></figure></p>
<p>来分割显示和不显示的文章</p>
<h3 id="关于plugin"><a href="#关于plugin" class="headerlink" title="关于plugin"></a>关于plugin</h3><p>hexo官网上有许多优秀的plugin，我找了一个比较有意思的<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="external">标签云插件</a><br>按照readme一步一步配置就可以实现动态的tagcloud了</p>
<p>最后上一切的起源：<a href="https://hexo.io/" target="_blank" rel="external">hexo</a></p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL (III) 字段类型选择]]></title>
      <url>/2016/04/30/mysql_uh3/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_4.bmp" alt=""><br>字段是组成一张表的最基本单元，但它们却是数据表设计时不得不严密考虑的部分，因为不恰当的字段类型选择，不仅容易造成数据库空间的浪费，以及冗余的产生，且在数据量巨大以及查询频繁的字段或表，将严重影响数据的读写速度。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="Int（bigint，int，mediumint，smallint，tinyint）"><a href="#Int（bigint，int，mediumint，smallint，tinyint）" class="headerlink" title="Int（bigint，int，mediumint，smallint，tinyint）"></a>Int（bigint，int，mediumint，smallint，tinyint）</h3><p>因为计算机本身只分辨数字型的数据，所以合理的使用整形字段可以提升数据读取的速度。</p>
<p>整形数据由大至小，从16个字节到1个字节不等，对于不同需求的表选择不同类型的int类型作为表的primary key是一个不错的选择。</p>
<p>这里还要提到的一点，虽然MySQL数据库提供了datetime类型的字段，但我们还是尽量以int类型的格式来存储时间戳的方法来保存时间数据，这样可以提高读取速度和减少I/O的开销。</p>
<p>在一些单选或者多选的字段里，也应当尽量避免使用枚举，适当的选用tinyint这样的短int数据是更好的选择。</p>
<hr>
<h3 id="Float（float，double，decimal）"><a href="#Float（float，double，decimal）" class="headerlink" title="Float（float，double，decimal）"></a>Float（float，double，decimal）</h3><p>其实在浮点类型的数据中，decimal并不是作为数字存储在数据库中的，相反他是以我们’厌恶’的字符类型存在。</p>
<p>在这里，我们不得不来讨论一下浮点型数的一些缺点，单/双精度的数据类型在数据库中超过一定位数之后会出现失去精度的的情况，这个位数的大小在6位小数，而我们存储一些类似价格，额度等字段时，需要一种完全精确的记录，而decimal（65，30）如此长度的记录数完全满足我们的需求，这是浮点类型数据我们应当关心的部分。</p>
<hr>
<h3 id="字符（char，varchar）"><a href="#字符（char，varchar）" class="headerlink" title="字符（char，varchar）"></a>字符（char，varchar）</h3><p>虽然字符类型的数据在读取时并不佳，但字符型的数据却是一个数据库不可忽略的部分。</p>
<p>char和varchar的不同体现在多个方面</p>
<p>1.char类型数据最大长度（255），而varchar类型数据的最大长度为（65535）</p>
<blockquote>
<p>这里需要注意的是，varchar类型的数据长度存储的字节长度，即varchar类型的数据需要考虑编码的原因</p>
</blockquote>
<p>2.两者最主要体现在两者侧重的方面不同，char类型数据属于定长数据，不论存储多少长度的数据，都占据一定的空间，而varchar数据则不论在表中设计多大的长度，都依照存储的字符串长度来决定占用的空间</p>
<p>3.因为varchar之所节省空间，是因为varchar经过了一层数据库的算法过滤，恰恰也是这层过滤，使得varchar类型的数据在读写速度上劣于char类型的数据。</p>
<p>总而言之，varchar和char两者，一个为了节省空间而浪费了时间，一个为了节省时间而浪费了空间，这就需要我们在设计表格的时候，谨慎的去考虑和取舍了。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字段优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (II) 引擎]]></title>
      <url>/2016/04/21/mysql_uh2/</url>
      <content type="html"><![CDATA[<p><img src="/css/images/mysql_1.jpg" alt="Mysql示意图"><br>这里，只简单的讨论两种常见的引擎：<span style="color:green"><strong>MyISAM</strong></span>和<span style="color:red"><strong>InnoDB</strong></span>的区别。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.</p>
<p>b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.</p>
<p>c. InnoDB不支持fulltext类型的索引.</p>
<p>d. InnoDB 中不保存表的具体行数，也就是说，<br>执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，<br>但是MyISAM只要简单的读出保存好的行数即可.</p>
<p>e. 对于auto_increment类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>f. delete from table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>g. load table from master操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用.</p>
<p>h. MyISAM支持表锁，InnoDB支持行锁。</p>
<hr>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>InnoDB的B-tree结构<br><img src="/css/images/mysql_2.jpg" alt="InnoDB_B-tree"></p>
<blockquote>
<p>如上图所示，InnoDB的搜索树由两层结构组成，每次对InnoDB引擎的表操作时，实际上是经过了两次的处理，先通过索引找到主键的位置，再获取对应主键的记录，这样不论是写入还是读取的速度都讲收到影响。</p>
</blockquote>
<p>MyISAM的B-tree结构<br><img src="/css/images/mysql_3.jpg" alt="MyISAM_B-tree"></p>
<blockquote>
<p>MyISAM的结构决定了，每次读取和写入的时候不用考虑主键的顺序重排，所以MyISAM引擎的表的读取速度较InnoDB的快</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql (I) 数据表设计规范]]></title>
      <url>/2016/04/03/mysql_uh1/</url>
      <content type="html"><![CDATA[<h4 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;俗话说，好的表结构是一个项目成功的一般，而在项目中我们一般按照三范式的规范来设计我们的表格。<br>三范式的具体要求如下：</p>
<ol>
<li>原子性（不可再分的字段）</li>
<li>非主键字段必须依赖主键</li>
<li>消除非主键之间的传递依赖</li>
</ol>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当然，三范式在网上存在许多不同的版本，但不论是哪个版本的三范式，其中心思想都是一样的，那就是设计出比较合理的数据表，尽可能的<strong>减少代码的冗余</strong>。</p>
<blockquote>
<p>但需要注意的是，代码的冗余只能<strong>减少</strong>，而不是消灭</p>
</blockquote>
<p>具体设计思路如下：</p>
<pre><code>id name order order_name address weather price (非设计规范表)
(拆分address字段保证设计表的原子性)
-&gt; id name order order_name country province city weather price
(将非主键依赖的weather的字段拆分出去)
-&gt; id name order order_name country province city price
(消除order和order_name之间的传递依赖，将非主键之间的传递依赖消除)
-&gt; id name order country province city price
</code></pre><h3 id="逆范式"><a href="#逆范式" class="headerlink" title="逆范式"></a>逆范式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实际项目中，并不是完全按三范式的规范来设计表的结构，具体的项目中，逆范式的设计有时候可以简化sql的语句，提高sql语句的执行效率，此时逆范式的设计明显更有利于我们的项目，这个情况下使用逆范式的设计将更为科学。</p>
<p>例如，我们现在有两张表，一张分类表（category），一张商品表（goods），这里我们项目需要查询分类id、分类名称、商品数量三个字段，具体的sql语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select c.*,count(g.goods_id) goods_num from category as c left join goods as g on c.cat_id = g.cat_id group by c.cat_id;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个使用jion连表查询的sql语句相对于简单的表结构并不简单，而如果我们给分类表加上一个对应的商品数量字段，这样的sql语句将大大简化，这个时候我们大可不必严守三范式的设计思路，不妨使用逆范式的方式来设计这张表。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 表设计 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
